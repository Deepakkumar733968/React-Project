{"ast":null,"code":"/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Utils } from \"../../common\";\nimport { Tab } from \"./tab\";\nimport { TabPanel } from \"./tabPanel\";\nimport { TabTitle } from \"./tabTitle\";\n/**\n * Component that may be inserted between any two children of `<Tabs>` to right-align all subsequent children.\n */\nexport var TabsExpander = function () {\n  return React.createElement(\"div\", {\n    className: Classes.FLEX_EXPANDER\n  });\n};\n/** @deprecated use `TabsExpander` instead */\nexport var Expander = TabsExpander;\nvar TAB_SELECTOR = \".\".concat(Classes.TAB);\n/**\n * Tabs component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tabs\n */\nvar Tabs = /** @class */function (_super) {\n  __extends(Tabs, _super);\n  function Tabs(props) {\n    var _this = _super.call(this, props) || this;\n    _this.tablistElement = null;\n    _this.refHandlers = {\n      tablist: function (tabElement) {\n        return _this.tablistElement = tabElement;\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var _a;\n      var direction = Utils.getArrowKeyDirection(e, [\"ArrowLeft\", \"ArrowUp\"], [\"ArrowRight\", \"ArrowDown\"]);\n      if (direction === undefined) return;\n      var focusedElement = (_a = Utils.getActiveElement(_this.tablistElement)) === null || _a === void 0 ? void 0 : _a.closest(TAB_SELECTOR);\n      // rest of this is potentially expensive and futile, so bail if no tab is focused\n      if (!focusedElement) return;\n      // must rely on DOM state because we have no way of mapping `focusedElement` to a React.JSX.Element\n      var enabledTabElements = _this.getTabElements('[aria-disabled=\"false\"]');\n      var focusedIndex = enabledTabElements.indexOf(focusedElement);\n      if (focusedIndex < 0) return;\n      e.preventDefault();\n      var length = enabledTabElements.length;\n      // auto-wrapping at 0 and `length`\n      var nextFocusedIndex = (focusedIndex + direction + length) % length;\n      enabledTabElements[nextFocusedIndex].focus();\n    };\n    _this.handleKeyPress = function (e) {\n      var targetTabElement = e.target.closest(TAB_SELECTOR);\n      if (targetTabElement != null && Utils.isKeyboardClick(e)) {\n        e.preventDefault();\n        targetTabElement.click();\n      }\n    };\n    _this.handleTabClick = function (newTabId, event) {\n      var _a, _b;\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, newTabId, _this.state.selectedTabId, event);\n      if (_this.props.selectedTabId === undefined) {\n        _this.setState({\n          selectedTabId: newTabId\n        });\n      }\n    };\n    _this.renderTabPanel = function (tab) {\n      var _a = tab.props,\n        className = _a.className,\n        panel = _a.panel,\n        id = _a.id,\n        panelClassName = _a.panelClassName;\n      if (panel === undefined) {\n        return undefined;\n      }\n      return React.createElement(TabPanel, __assign({}, tab.props, {\n        key: id,\n        className: classNames(className, panelClassName),\n        parentId: _this.props.id,\n        selectedTabId: _this.state.selectedTabId\n      }));\n    };\n    _this.renderTabTitle = function (child) {\n      if (isTabElement(child)) {\n        var id = child.props.id;\n        return React.createElement(TabTitle, __assign({}, child.props, {\n          parentId: _this.props.id,\n          onClick: _this.handleTabClick,\n          selected: id === _this.state.selectedTabId\n        }));\n      }\n      return child;\n    };\n    var selectedTabId = _this.getInitialSelectedTabId();\n    _this.state = {\n      selectedTabId: selectedTabId\n    };\n    return _this;\n  }\n  Tabs.getDerivedStateFromProps = function (_a) {\n    var selectedTabId = _a.selectedTabId;\n    if (selectedTabId !== undefined) {\n      // keep state in sync with controlled prop, so state is canonical source of truth\n      return {\n        selectedTabId: selectedTabId\n      };\n    }\n    return null;\n  };\n  Tabs.prototype.render = function () {\n    var _a;\n    var _b = this.props,\n      animate = _b.animate,\n      children = _b.children,\n      className = _b.className,\n      fill = _b.fill,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      large = _b.large,\n      renderActiveTabPanelOnly = _b.renderActiveTabPanelOnly,\n      _c = _b.size,\n      size = _c === void 0 ? \"medium\" : _c,\n      vertical = _b.vertical;\n    var _d = this.state,\n      indicatorWrapperStyle = _d.indicatorWrapperStyle,\n      selectedTabId = _d.selectedTabId;\n    var tabTitles = React.Children.map(children, this.renderTabTitle);\n    var tabPanels = this.getTabChildren().filter(renderActiveTabPanelOnly ? function (tab) {\n      return tab.props.id === selectedTabId;\n    } : function () {\n      return true;\n    }).map(this.renderTabPanel);\n    var tabIndicator = animate ? React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR_WRAPPER,\n      style: indicatorWrapperStyle\n    }, React.createElement(\"div\", {\n      className: Classes.TAB_INDICATOR\n    })) : null;\n    var classes = classNames(Classes.TABS, className, (_a = {}, _a[Classes.VERTICAL] = vertical, _a[Classes.FILL] = fill, _a));\n    var tabListClasses = classNames(Classes.TAB_LIST, Classes.sizeClass(size, {\n      large: large\n    }));\n    return React.createElement(\"div\", {\n      className: classes\n    }, React.createElement(\"div\", {\n      className: tabListClasses,\n      onKeyDown: this.handleKeyDown,\n      // eslint-disable-next-line @typescript-eslint/no-deprecated\n      onKeyPress: this.handleKeyPress,\n      ref: this.refHandlers.tablist,\n      role: \"tablist\"\n    }, tabIndicator, tabTitles), tabPanels);\n  };\n  Tabs.prototype.componentDidMount = function () {\n    this.moveSelectionIndicator(false);\n  };\n  Tabs.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (this.state.selectedTabId !== prevState.selectedTabId) {\n      this.moveSelectionIndicator();\n    } else if (prevState.selectedTabId != null) {\n      // comparing React nodes is difficult to do with simple logic, so\n      // shallowly compare just their props as a workaround.\n      var didChildrenChange = !Utils.arraysEqual(this.getTabChildrenProps(prevProps), this.getTabChildrenProps(), Utils.shallowCompareKeys);\n      if (didChildrenChange) {\n        this.moveSelectionIndicator();\n      }\n    }\n  };\n  Tabs.prototype.getInitialSelectedTabId = function () {\n    // NOTE: providing an unknown ID will hide the selection\n    var _a = this.props,\n      defaultSelectedTabId = _a.defaultSelectedTabId,\n      selectedTabId = _a.selectedTabId;\n    if (selectedTabId !== undefined) {\n      return selectedTabId;\n    } else if (defaultSelectedTabId !== undefined) {\n      return defaultSelectedTabId;\n    } else {\n      // select first tab in absence of user input\n      var tabs = this.getTabChildren();\n      return tabs.length === 0 ? undefined : tabs[0].props.id;\n    }\n  };\n  Tabs.prototype.getTabChildrenProps = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return this.getTabChildren(props).map(function (child) {\n      return child.props;\n    });\n  };\n  /** Filters children to only `<Tab>`s */\n  Tabs.prototype.getTabChildren = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n    return React.Children.toArray(props.children).filter(isTabElement);\n  };\n  /** Queries root HTML element for all tabs with optional filter selector */\n  Tabs.prototype.getTabElements = function (subselector) {\n    if (subselector === void 0) {\n      subselector = \"\";\n    }\n    if (this.tablistElement == null) {\n      return [];\n    }\n    return Array.from(this.tablistElement.querySelectorAll(TAB_SELECTOR + subselector));\n  };\n  /**\n   * Calculate the new height, width, and position of the tab indicator.\n   * Store the CSS values so the transition animation can start.\n   */\n  Tabs.prototype.moveSelectionIndicator = function (animate) {\n    if (animate === void 0) {\n      animate = true;\n    }\n    if (this.tablistElement == null || !this.props.animate) {\n      return;\n    }\n    var tabIdSelector = \"\".concat(TAB_SELECTOR, \"[data-tab-id=\\\"\").concat(this.state.selectedTabId, \"\\\"]\");\n    var selectedTabElement = this.tablistElement.querySelector(tabIdSelector);\n    var indicatorWrapperStyle = {\n      display: \"none\"\n    };\n    if (selectedTabElement != null) {\n      var clientHeight = selectedTabElement.clientHeight,\n        clientWidth = selectedTabElement.clientWidth,\n        offsetLeft = selectedTabElement.offsetLeft,\n        offsetTop = selectedTabElement.offsetTop;\n      indicatorWrapperStyle = {\n        height: clientHeight,\n        transform: \"translateX(\".concat(Math.floor(offsetLeft), \"px) translateY(\").concat(Math.floor(offsetTop), \"px)\"),\n        width: clientWidth\n      };\n      if (!animate) {\n        indicatorWrapperStyle.transition = \"none\";\n      }\n    }\n    this.setState({\n      indicatorWrapperStyle: indicatorWrapperStyle\n    });\n  };\n  /**\n   * Insert a `TabsExpander` between any two children to right-align all subsequent children.\n   *\n   * @deprecated use `TabsExpander`\n   */\n  Tabs.Expander = TabsExpander;\n  Tabs.Tab = Tab;\n  Tabs.defaultProps = {\n    animate: true,\n    fill: false,\n    large: false,\n    renderActiveTabPanelOnly: false,\n    size: \"medium\",\n    vertical: false\n  };\n  Tabs.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Tabs\");\n  return Tabs;\n}(AbstractPureComponent);\nexport { Tabs };\nfunction isTabElement(child) {\n  return Utils.isElementOfType(child, Tab);\n}","map":{"version":3,"names":["classNames","React","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","Utils","Tab","TabPanel","TabTitle","TabsExpander","createElement","className","FLEX_EXPANDER","Expander","TAB_SELECTOR","concat","TAB","Tabs","_super","__extends","props","_this","call","tablistElement","refHandlers","tablist","tabElement","handleKeyDown","e","direction","getArrowKeyDirection","undefined","focusedElement","_a","getActiveElement","closest","enabledTabElements","getTabElements","focusedIndex","indexOf","preventDefault","length","nextFocusedIndex","focus","handleKeyPress","targetTabElement","target","isKeyboardClick","click","handleTabClick","newTabId","event","_b","onChange","state","selectedTabId","setState","renderTabPanel","tab","panel","id","panelClassName","__assign","key","parentId","renderTabTitle","child","isTabElement","onClick","selected","getInitialSelectedTabId","getDerivedStateFromProps","prototype","render","animate","children","fill","large","renderActiveTabPanelOnly","_c","size","vertical","_d","indicatorWrapperStyle","tabTitles","Children","map","tabPanels","getTabChildren","filter","tabIndicator","TAB_INDICATOR_WRAPPER","style","TAB_INDICATOR","classes","TABS","VERTICAL","FILL","tabListClasses","TAB_LIST","sizeClass","onKeyDown","onKeyPress","ref","role","componentDidMount","moveSelectionIndicator","componentDidUpdate","prevProps","prevState","didChildrenChange","arraysEqual","getTabChildrenProps","shallowCompareKeys","defaultSelectedTabId","tabs","toArray","subselector","Array","from","querySelectorAll","tabIdSelector","selectedTabElement","querySelector","display","clientHeight","clientWidth","offsetLeft","offsetTop","height","transform","Math","floor","width","transition","defaultProps","displayName","isElementOfType"],"sources":["C:\\Users\\deepa\\Deepak\\Working-File\\React-Project\\new-working-file\\React-Project\\my-app\\node_modules\\@blueprintjs\\core\\src\\components\\tabs\\tabs.tsx"],"sourcesContent":["/*\n * Copyright 2015 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, type NonSmallSize, type Props, Utils } from \"../../common\";\n\nimport { Tab, type TabId, type TabProps } from \"./tab\";\nimport { TabPanel } from \"./tabPanel\";\nimport { TabTitle } from \"./tabTitle\";\n\n/**\n * Component that may be inserted between any two children of `<Tabs>` to right-align all subsequent children.\n */\nexport const TabsExpander: React.FC = () => <div className={Classes.FLEX_EXPANDER} />;\n\n/** @deprecated use `TabsExpander` instead */\nexport const Expander = TabsExpander;\n\ntype TabElement = React.ReactElement<TabProps & { children: React.ReactNode }>;\n\nconst TAB_SELECTOR = `.${Classes.TAB}`;\n\nexport interface TabsProps extends Props {\n    /**\n     * Whether the selected tab indicator should animate its movement.\n     *\n     * @default true\n     */\n    animate?: boolean;\n\n    /** Tab elements. */\n    children?: React.ReactNode;\n\n    /**\n     * Initial selected tab `id`, for uncontrolled usage.\n     * Note that this prop refers only to `<Tab>` children; other types of elements are ignored.\n     *\n     * @default first tab\n     */\n    defaultSelectedTabId?: TabId;\n\n    /**\n     * Unique identifier for this `Tabs` container. This will be combined with the `id` of each\n     * `Tab` child to generate ARIA accessibility attributes. IDs are required and should be\n     * unique on the page to support server-side rendering.\n     */\n    id: TabId;\n\n    /**\n     * If set to `true`, the tab titles will display with larger styling.\n     * This will apply large styles only to the tabs at this level, not to nested tabs.\n     *\n     * @deprecated use `size=\"large\"` instead\n     * @default false\n     */\n    large?: boolean;\n\n    /**\n     * The size of the tab titles.\n     *\n     * @default \"medium\"\n     */\n    size?: NonSmallSize;\n\n    /**\n     * Whether inactive tab panels should be removed from the DOM and unmounted in React.\n     * This can be a performance enhancement when rendering many complex panels, but requires\n     * careful support for unmounting and remounting.\n     *\n     * @default false\n     */\n    renderActiveTabPanelOnly?: boolean;\n\n    /**\n     * Selected tab `id`, for controlled usage.\n     * Providing this prop will put the component in controlled mode.\n     * Unknown ids will result in empty selection (no errors).\n     */\n    selectedTabId?: TabId;\n\n    /**\n     * Whether to show tabs stacked vertically on the left side.\n     *\n     * @default false\n     */\n    vertical?: boolean;\n\n    /**\n     * Whether to make the tabs list fill the height of its parent.\n     *\n     * This has no effect when `vertical={true}`.\n     * This is not recommended when tab panels are defined within this component subtree, as the height computation will\n     * include the panel height, which is usually not intended. Instead, it works well if the panels are rendered\n     * elsewhere in the React tree.\n     *\n     * @default false\n     */\n    fill?: boolean;\n\n    /**\n     * A callback function that is invoked when a tab in the tab list is clicked.\n     */\n    onChange?(newTabId: TabId, prevTabId: TabId | undefined, event: React.MouseEvent<HTMLElement>): void;\n}\n\nexport interface TabsState {\n    indicatorWrapperStyle?: React.CSSProperties;\n    selectedTabId?: TabId;\n}\n\n/**\n * Tabs component.\n *\n * @see https://blueprintjs.com/docs/#core/components/tabs\n */\nexport class Tabs extends AbstractPureComponent<TabsProps, TabsState> {\n    /**\n     * Insert a `TabsExpander` between any two children to right-align all subsequent children.\n     *\n     * @deprecated use `TabsExpander`\n     */\n    public static Expander = TabsExpander;\n\n    public static Tab = Tab;\n\n    public static defaultProps: Partial<TabsProps> = {\n        animate: true,\n        fill: false,\n        large: false,\n        renderActiveTabPanelOnly: false,\n        size: \"medium\",\n        vertical: false,\n    };\n\n    public static displayName = `${DISPLAYNAME_PREFIX}.Tabs`;\n\n    public static getDerivedStateFromProps({ selectedTabId }: TabsProps) {\n        if (selectedTabId !== undefined) {\n            // keep state in sync with controlled prop, so state is canonical source of truth\n            return { selectedTabId };\n        }\n        return null;\n    }\n\n    private tablistElement: HTMLDivElement | null = null;\n\n    private refHandlers = {\n        tablist: (tabElement: HTMLDivElement) => (this.tablistElement = tabElement),\n    };\n\n    constructor(props: TabsProps) {\n        super(props);\n        const selectedTabId = this.getInitialSelectedTabId();\n        this.state = { selectedTabId };\n    }\n\n    public render() {\n        const {\n            animate,\n            children,\n            className,\n            fill,\n            // eslint-disable-next-line @typescript-eslint/no-deprecated\n            large,\n            renderActiveTabPanelOnly,\n            size = \"medium\",\n            vertical,\n        } = this.props;\n        const { indicatorWrapperStyle, selectedTabId } = this.state;\n\n        const tabTitles = React.Children.map(children, this.renderTabTitle);\n\n        const tabPanels = this.getTabChildren()\n            .filter(renderActiveTabPanelOnly ? tab => tab.props.id === selectedTabId : () => true)\n            .map(this.renderTabPanel);\n\n        const tabIndicator = animate ? (\n            <div className={Classes.TAB_INDICATOR_WRAPPER} style={indicatorWrapperStyle}>\n                <div className={Classes.TAB_INDICATOR} />\n            </div>\n        ) : null;\n\n        const classes = classNames(Classes.TABS, className, {\n            [Classes.VERTICAL]: vertical,\n            [Classes.FILL]: fill,\n        });\n        const tabListClasses = classNames(Classes.TAB_LIST, Classes.sizeClass(size, { large }));\n\n        return (\n            <div className={classes}>\n                <div\n                    className={tabListClasses}\n                    onKeyDown={this.handleKeyDown}\n                    // eslint-disable-next-line @typescript-eslint/no-deprecated\n                    onKeyPress={this.handleKeyPress}\n                    ref={this.refHandlers.tablist}\n                    role=\"tablist\"\n                >\n                    {tabIndicator}\n                    {tabTitles}\n                </div>\n                {tabPanels}\n            </div>\n        );\n    }\n\n    public componentDidMount() {\n        this.moveSelectionIndicator(false);\n    }\n\n    public componentDidUpdate(prevProps: TabsProps, prevState: TabsState) {\n        if (this.state.selectedTabId !== prevState.selectedTabId) {\n            this.moveSelectionIndicator();\n        } else if (prevState.selectedTabId != null) {\n            // comparing React nodes is difficult to do with simple logic, so\n            // shallowly compare just their props as a workaround.\n            const didChildrenChange = !Utils.arraysEqual(\n                this.getTabChildrenProps(prevProps),\n                this.getTabChildrenProps(),\n                Utils.shallowCompareKeys,\n            );\n            if (didChildrenChange) {\n                this.moveSelectionIndicator();\n            }\n        }\n    }\n\n    private getInitialSelectedTabId() {\n        // NOTE: providing an unknown ID will hide the selection\n        const { defaultSelectedTabId, selectedTabId } = this.props;\n        if (selectedTabId !== undefined) {\n            return selectedTabId;\n        } else if (defaultSelectedTabId !== undefined) {\n            return defaultSelectedTabId;\n        } else {\n            // select first tab in absence of user input\n            const tabs = this.getTabChildren();\n            return tabs.length === 0 ? undefined : tabs[0].props.id;\n        }\n    }\n\n    private getTabChildrenProps(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return this.getTabChildren(props).map(child => child.props);\n    }\n\n    /** Filters children to only `<Tab>`s */\n    private getTabChildren(props: TabsProps & { children?: React.ReactNode } = this.props) {\n        return React.Children.toArray(props.children).filter(isTabElement);\n    }\n\n    /** Queries root HTML element for all tabs with optional filter selector */\n    private getTabElements(subselector = \"\") {\n        if (this.tablistElement == null) {\n            return [];\n        }\n        return Array.from(this.tablistElement.querySelectorAll<HTMLElement>(TAB_SELECTOR + subselector));\n    }\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const direction = Utils.getArrowKeyDirection(e, [\"ArrowLeft\", \"ArrowUp\"], [\"ArrowRight\", \"ArrowDown\"]);\n        if (direction === undefined) return;\n\n        const focusedElement = Utils.getActiveElement(this.tablistElement)?.closest<HTMLElement>(TAB_SELECTOR);\n        // rest of this is potentially expensive and futile, so bail if no tab is focused\n        if (!focusedElement) return;\n\n        // must rely on DOM state because we have no way of mapping `focusedElement` to a React.JSX.Element\n        const enabledTabElements = this.getTabElements('[aria-disabled=\"false\"]');\n        const focusedIndex = enabledTabElements.indexOf(focusedElement);\n        if (focusedIndex < 0) return;\n\n        e.preventDefault();\n        const { length } = enabledTabElements;\n        // auto-wrapping at 0 and `length`\n        const nextFocusedIndex = (focusedIndex + direction + length) % length;\n        enabledTabElements[nextFocusedIndex].focus();\n    };\n\n    private handleKeyPress = (e: React.KeyboardEvent<HTMLDivElement>) => {\n        const targetTabElement = (e.target as HTMLElement).closest<HTMLElement>(TAB_SELECTOR);\n        if (targetTabElement != null && Utils.isKeyboardClick(e)) {\n            e.preventDefault();\n            targetTabElement.click();\n        }\n    };\n\n    private handleTabClick = (newTabId: TabId, event: React.MouseEvent<HTMLElement>) => {\n        this.props.onChange?.(newTabId, this.state.selectedTabId, event);\n        if (this.props.selectedTabId === undefined) {\n            this.setState({ selectedTabId: newTabId });\n        }\n    };\n\n    /**\n     * Calculate the new height, width, and position of the tab indicator.\n     * Store the CSS values so the transition animation can start.\n     */\n    private moveSelectionIndicator(animate = true) {\n        if (this.tablistElement == null || !this.props.animate) {\n            return;\n        }\n\n        const tabIdSelector = `${TAB_SELECTOR}[data-tab-id=\"${this.state.selectedTabId}\"]`;\n        const selectedTabElement = this.tablistElement.querySelector<HTMLElement>(tabIdSelector);\n\n        let indicatorWrapperStyle: React.CSSProperties = { display: \"none\" };\n        if (selectedTabElement != null) {\n            const { clientHeight, clientWidth, offsetLeft, offsetTop } = selectedTabElement;\n            indicatorWrapperStyle = {\n                height: clientHeight,\n                transform: `translateX(${Math.floor(offsetLeft)}px) translateY(${Math.floor(offsetTop)}px)`,\n                width: clientWidth,\n            };\n\n            if (!animate) {\n                indicatorWrapperStyle.transition = \"none\";\n            }\n        }\n        this.setState({ indicatorWrapperStyle });\n    }\n\n    private renderTabPanel = (tab: TabElement) => {\n        const { className, panel, id, panelClassName } = tab.props;\n        if (panel === undefined) {\n            return undefined;\n        }\n\n        return (\n            <TabPanel\n                {...tab.props}\n                key={id}\n                className={classNames(className, panelClassName)}\n                parentId={this.props.id}\n                selectedTabId={this.state.selectedTabId}\n            />\n        );\n    };\n\n    private renderTabTitle = (child: React.ReactNode) => {\n        if (isTabElement(child)) {\n            const { id } = child.props;\n            return (\n                <TabTitle\n                    {...child.props}\n                    parentId={this.props.id}\n                    onClick={this.handleTabClick}\n                    selected={id === this.state.selectedTabId}\n                />\n            );\n        }\n        return child;\n    };\n}\n\nfunction isTabElement(child: any): child is TabElement {\n    return Utils.isElementOfType(child, Tab);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}