{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, mergeRefs, refHandler, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay2 } from \"../overlay2/overlay2\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nvar Popover = /** @class */function (_super) {\n  __extends(Popover, _super);\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      hasDarkParent: false,\n      isClosingViaEscapeKeypress: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    _this.popoverElement = null;\n    /** Popover ref handler */\n    _this.popoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n    /**\n     * Target DOM element ref.\n     *\n     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target\n     * DOM element in order to observe its dimensions.\n     *\n     * @public for testing\n     */\n    _this.targetRef = React.createRef();\n    /**\n     * Overlay2 transition container element ref.\n     */\n    _this.transitionContainerElement = React.createRef();\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    _this.isMouseInTargetOrPopover = false;\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    _this.lostFocusOnSamePage = true;\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === PopoverInteractionKind.HOVER || _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    _this.reposition = function () {\n      var _a;\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n      var _d, _e;\n      var popperChildRef = _a.ref;\n      var _f = _this.props,\n        children = _f.children,\n        className = _f.className,\n        disabled = _f.disabled,\n        fill = _f.fill,\n        openOnTargetFocus = _f.openOnTargetFocus,\n        renderTarget = _f.renderTarget;\n      var isOpen = _this.state.isOpen;\n      var isControlled = _this.isControlled();\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n      var targetTagName = _this.props.targetTagName;\n      if (fill) {\n        targetTagName = \"div\";\n      }\n      // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n      // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17\n      var ref = mergeRefs(popperChildRef, _this.targetRef);\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onContextMenu: _this.handleTargetContextMenu,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick,\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        onKeyDown: _this.handleKeyDown\n      };\n      // Ensure target is focusable if relevant prop enabled\n      var targetTabIndex = !_this.getIsContentEmpty() && !disabled && openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n      var ownTargetProps = __assign({\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER_TARGET, (_b = {}, _b[Classes.POPOVER_OPEN] = isOpen,\n        // this class is mainly useful for button targets\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        ref: ref\n      }, targetEventHandlers);\n      var childTargetProps = {\n        \"aria-expanded\": isHoverInteractionKind ? undefined : isOpen,\n        \"aria-haspopup\": _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY ? undefined : (_d = _this.props.popupKind) !== null && _d !== void 0 ? _d : \"menu\"\n      };\n      var targetModifierClasses = (_c = {},\n      // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n      // uncontrolled popovers when they are opened by a user interaction\n      _c[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n      // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n      _c[Classes.FILL] = fill, _c);\n      var target;\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign(__assign({}, ownTargetProps), childTargetProps), {\n          className: classNames(ownTargetProps.className, targetModifierClasses),\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen,\n          tabIndex: targetTabIndex\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n        if (childTarget === undefined) {\n          return null;\n        }\n        var clonedTarget = React.cloneElement(childTarget, __assign(__assign({}, childTargetProps), {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n          tabIndex: (_e = childTarget.props.tabIndex) !== null && _e !== void 0 ? _e : targetTabIndex\n        }));\n        var wrappedTarget = React.createElement(targetTagName, __assign(__assign({}, ownTargetProps), _this.props.targetProps), clonedTarget);\n        target = wrappedTarget;\n      }\n      // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can\n      // notify both popper.js and our components about the mounted DOM element.\n      return React.createElement(ResizeSensor, {\n        targetRef: _this.targetRef,\n        onResize: _this.reposition\n      }, target);\n    };\n    _this.renderPopover = function (popperProps) {\n      var _a;\n      var _b = _this.props,\n        autoFocus = _b.autoFocus,\n        enforceFocus = _b.enforceFocus,\n        backdropProps = _b.backdropProps,\n        canEscapeKeyClose = _b.canEscapeKeyClose,\n        hasBackdrop = _b.hasBackdrop,\n        interactionKind = _b.interactionKind,\n        usePortal = _b.usePortal;\n      var _c = _this.state,\n        isClosingViaEscapeKeypress = _c.isClosingViaEscapeKeypress,\n        isOpen = _c.isOpen;\n      // compute an appropriate transform origin so the scale animation points towards target\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);\n      // need to update our reference to this function on every render as it will change.\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick,\n        // treat ENTER/SPACE keys the same as a click for accessibility\n        onKeyDown: function (event) {\n          return Utils.isKeyboardClick(event) && _this.handlePopoverClick(event);\n        }\n      };\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a[Classes.POPOVER_MATCH_TARGET_WIDTH] = _this.props.matchTargetWidth, _a[Classes.POPOVER_REFERENCE_HIDDEN] = popperProps.isReferenceHidden === true, _a[Classes.POPOVER_POPPER_ESCAPED] = popperProps.hasPopperEscaped === true, _a), \"\".concat(Classes.POPOVER_CONTENT_PLACEMENT, \"-\").concat(basePlacement), _this.props.popoverClassName);\n      var defaultAutoFocus = _this.isHoverInteractionKind() ? false : undefined;\n      // if hover interaction, it doesn't make sense to take over focus control\n      var shouldReturnFocusOnClose = _this.isHoverInteractionKind() ? false : isClosingViaEscapeKeypress ? true : _this.props.shouldReturnFocusOnClose;\n      return React.createElement(Overlay2, {\n        autoFocus: autoFocus !== null && autoFocus !== void 0 ? autoFocus : defaultAutoFocus,\n        backdropClassName: Classes.POPOVER_BACKDROP,\n        backdropProps: backdropProps,\n        canEscapeKeyClose: canEscapeKeyClose,\n        canOutsideClickClose: interactionKind === PopoverInteractionKind.CLICK,\n        childRef: _this.transitionContainerElement,\n        enforceFocus: enforceFocus,\n        hasBackdrop: hasBackdrop,\n        isOpen: isOpen,\n        lazy: _this.props.lazy,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER,\n        usePortal: usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer,\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        portalStopPropagationEvents: _this.props.portalStopPropagationEvents,\n        shouldReturnFocusOnClose: shouldReturnFocusOnClose\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER_TRANSITION_CONTAINER,\n        // We need to attach a ref that notifies both react-popper and our Popover component about the DOM\n        // element inside the Overlay2. We cannot re-use `PopperChildrenProps.ref` because Overlay2 only\n        // accepts a ref object (not a callback) due to a CSSTransition API limitation.\n        // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n        // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Popper.js#L94\n        ref: mergeRefs(popperProps.ref, _this.transitionContainerElement),\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.props.content)))));\n    };\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n        _this.handleMouseEnter(e);\n      }\n    };\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget != null) {\n          // if the next element to receive focus is within the popover, we'll want to leave the\n          // popover open.\n          if (e.relatedTarget !== _this.popoverElement && !_this.isElementInPopover(e.relatedTarget)) {\n            _this.handleMouseLeave(e);\n          }\n        } else {\n          _this.handleMouseLeave(e);\n        }\n      }\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n    _this.handleTargetContextMenu = function (e) {\n      // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n      // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n      if (e.defaultPrevented) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true;\n      // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false;\n      // Wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa). Make sure to persist the event since\n      // we need to access `nativeEvent` in `this.setOpenState()`.\n      e.persist();\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        }\n        // user-configurable closing delay is helpful when moving mouse from target to popover\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n    _this.handlePopoverClick = function (e) {\n      var _a, _b, _c;\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var eventPopoverV1 = eventTarget.closest(\".\".concat(Classes.POPOVER));\n      var isEventFromSelf = (eventPopover !== null && eventPopover !== void 0 ? eventPopover : eventPopoverV1) === _this.getPopoverElement();\n      var isEventPopoverCapturing = (_b = (_a = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _a !== void 0 ? _a : eventPopoverV1 === null || eventPopoverV1 === void 0 ? void 0 : eventPopoverV1.classList.contains(Classes.POPOVER_CAPTURING_DISMISS)) !== null && _b !== void 0 ? _b : false;\n      // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n      var dismissElement = eventTarget.closest(\".\".concat(Classes.POPOVER_DISMISS, \", .\").concat(Classes.POPOVER_DISMISS_OVERRIDE));\n      var shouldDismiss = (_c = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER_DISMISS)) !== null && _c !== void 0 ? _c : false;\n      var isDisabled = eventTarget.closest(\":disabled, .\".concat(Classes.DISABLED)) != null;\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleOverlayClose = function (e) {\n      var _a;\n      if (_this.targetRef.current == null || e === undefined) {\n        return;\n      }\n      var event = (_a = e.nativeEvent) !== null && _a !== void 0 ? _a : e;\n      var eventTarget = event.composed ? event.composedPath()[0] : event.target;\n      // if click was in target, target event listener will handle things, so don't close\n      if (!Utils.elementIsOrContains(_this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n    _this.handleKeyDown = function (e) {\n      var isKeyboardClick = Utils.isKeyboardClick(e);\n      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n      if (isKeyboardClick) {\n        _this.handleTargetClick(e);\n      }\n    };\n    _this.handleTargetClick = function (e) {\n      // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n      // see: https://github.com/palantir/blueprint/issues/5775\n      var shouldIgnoreClick = _this.state.isOpen && _this.isSimulatedButtonClick(e);\n      if (!shouldIgnoreClick) {\n        // ensure click did not originate from within inline popover before closing\n        if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n          if (_this.props.isOpen == null) {\n            _this.setState(function (prevState) {\n              return {\n                isOpen: !prevState.isOpen\n              };\n            });\n          } else {\n            _this.setOpenState(!_this.props.isOpen, e);\n          }\n        }\n      }\n    };\n    _this.isSimulatedButtonClick = function (e) {\n      return !e.isTrusted && e.target.matches(\".\".concat(Classes.BUTTON));\n    };\n    return _this;\n  }\n  // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n  // so if we want to look at our actual popover element, we need to reach inside a bit\n  Popover.prototype.getPopoverElement = function () {\n    var _a;\n    return (_a = this.popoverElement) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(Classes.POPOVER));\n  };\n  Popover.prototype.getIsOpen = function (props) {\n    var _a;\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n  Popover.prototype.render = function () {\n    var _a = this.props,\n      disabled = _a.disabled,\n      placement = _a.placement,\n      _b = _a.position,\n      position = _b === void 0 ? \"auto\" : _b,\n      positioningStrategy = _a.positioningStrategy;\n    var isOpen = this.state.isOpen;\n    if (this.getIsContentEmpty()) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n      }\n      // just render the target without a content overlay if there is no content to display\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n    // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode\n    // see https://github.com/floating-ui/react-popper/pull/459\n    return React.createElement(Manager, null, React.createElement(Reference, null, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.popoverRef,\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(position),\n      strategy: positioningStrategy,\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover));\n  };\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n  Popover.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen);\n      // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n    if (props.placement !== undefined && props.position !== undefined) {\n      console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n    }\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetProp = props.renderTarget !== undefined;\n    var hasTargetPropsProp = props.targetProps !== undefined;\n    if (childrenCount === 0 && !hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_REQUIRES_TARGET);\n    }\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n    if (childrenCount > 0 && hasRenderTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n    if (hasRenderTargetProp && hasTargetPropsProp) {\n      console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n    }\n  };\n  Popover.prototype.getPopperModifiers = function () {\n    var _a, _b, _c, _d;\n    var _e = this.props,\n      matchTargetWidth = _e.matchTargetWidth,\n      modifiers = _e.modifiers,\n      modifiersCustom = _e.modifiersCustom;\n    var popperModifiers = [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n    if (matchTargetWidth) {\n      popperModifiers.push(matchReferenceWidthModifier);\n    }\n    if (modifiersCustom !== undefined) {\n      popperModifiers.push.apply(popperModifiers, modifiersCustom);\n    }\n    return popperModifiers;\n  };\n  // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n    var _a, _b, _c, _d, _e;\n    // cancel any existing timeout because we have new state\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n    if (timeout !== undefined && timeout > 0) {\n      // Persist the react event since it will be used in a later macrotask.\n      e === null || e === void 0 ? void 0 : e.persist();\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n        this.setState({\n          isClosingViaEscapeKeypress: isEscapeKeypressEvent(e === null || e === void 0 ? void 0 : e.nativeEvent)\n        });\n      }\n    }\n  };\n  Popover.prototype.updateDarkParent = function () {\n    var _a;\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = ((_a = this.targetRef.current) === null || _a === void 0 ? void 0 : _a.closest(\".\".concat(Classes.DARK))) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n  Popover.prototype.isElementInPopover = function (element) {\n    var _a, _b;\n    return (_b = (_a = this.getPopoverElement()) === null || _a === void 0 ? void 0 : _a.contains(element)) !== null && _b !== void 0 ? _b : false;\n  };\n  Popover.prototype.getIsContentEmpty = function () {\n    var content = this.props.content;\n    return content == null || Utils.isEmptyString(content);\n  };\n  Popover.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Popover\");\n  Popover.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    matchTargetWidth: false,\n    minimal: false,\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` or `position` here because that would trigger\n    // a warning in validateProps if the other prop is specified by a user of this component\n    positioningStrategy: \"absolute\",\n    renderTarget: undefined,\n    shouldReturnFocusOnClose: false,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover;\n}(AbstractPureComponent);\nexport { Popover };\nfunction isEscapeKeypressEvent(e) {\n  return e instanceof KeyboardEvent && e.key === \"Escape\";\n}\nfunction noop() {\n  // no-op\n}","map":{"version":3,"names":["classNames","React","Manager","Popper","Reference","AbstractPureComponent","Classes","DISPLAYNAME_PREFIX","mergeRefs","refHandler","Utils","Errors","Overlay2","ResizeSensor","Tooltip","matchReferenceWidthModifier","POPOVER_ARROW_SVG_SIZE","PopoverArrow","positionToPlacement","getBasePlacement","getTransformOrigin","PopoverInteractionKind","CLICK","CLICK_TARGET_ONLY","HOVER","HOVER_TARGET_ONLY","Popover","_super","__extends","_this","state","hasDarkParent","isClosingViaEscapeKeypress","isOpen","getIsOpen","props","popoverElement","popoverRef","targetRef","createRef","transitionContainerElement","isMouseInTargetOrPopover","lostFocusOnSamePage","isControlled","undefined","isArrowEnabled","_a","_b","minimal","modifiers","arrow","enabled","isHoverInteractionKind","interactionKind","reposition","popperScheduleUpdate","call","renderTarget","popperChildRef","ref","_f","children","className","disabled","fill","openOnTargetFocus","targetTagName","targetEventHandlers","onBlur","handleTargetBlur","onContextMenu","handleTargetContextMenu","onFocus","handleTargetFocus","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","onClick","handleTargetClick","onKeyDown","handleKeyDown","targetTabIndex","getIsContentEmpty","ownTargetProps","__assign","POPOVER_TARGET","POPOVER_OPEN","ACTIVE","childTargetProps","_d","popupKind","targetModifierClasses","_c","FILL","target","tabIndex","childTarget","ensureElement","Children","toArray","clonedTarget","cloneElement","isElementOfType","_e","wrappedTarget","createElement","targetProps","onResize","renderPopover","popperProps","autoFocus","enforceFocus","backdropProps","canEscapeKeyClose","hasBackdrop","usePortal","transformOrigin","placement","arrowProps","style","update","popoverHandlers","handlePopoverClick","event","isKeyboardClick","basePlacement","popoverClasses","POPOVER","DARK","inheritDarkTheme","MINIMAL","POPOVER_CAPTURING_DISMISS","captureDismiss","POPOVER_MATCH_TARGET_WIDTH","matchTargetWidth","POPOVER_REFERENCE_HIDDEN","isReferenceHidden","POPOVER_POPPER_ESCAPED","hasPopperEscaped","concat","POPOVER_CONTENT_PLACEMENT","popoverClassName","defaultAutoFocus","shouldReturnFocusOnClose","backdropClassName","POPOVER_BACKDROP","canOutsideClickClose","childRef","lazy","onClose","handleOverlayClose","onClosed","onClosing","onOpened","onOpening","transitionDuration","transitionName","portalClassName","portalContainer","portalStopPropagationEvents","POPOVER_TRANSITION_CONTAINER","POPOVER_CONTENT","content","e","relatedTarget","isElementInPopover","defaultPrevented","setOpenState","hoverOpenDelay","persist","setTimeout","hoverCloseDelay","eventTarget","eventPopover","closest","eventPopoverV1","isEventFromSelf","getPopoverElement","isEventPopoverCapturing","classList","contains","dismissElement","POPOVER_DISMISS","POPOVER_DISMISS_OVERRIDE","shouldDismiss","isDisabled","DISABLED","current","nativeEvent","composed","composedPath","elementIsOrContains","KeyboardEvent","shouldIgnoreClick","isSimulatedButtonClick","setState","prevState","isTrusted","matches","BUTTON","prototype","querySelector","defaultIsOpen","render","position","positioningStrategy","isNodeEnv","console","warn","POPOVER_WARN_EMPTY_CONTENT","noop","innerRef","strategy","getPopperModifiers","componentDidMount","updateDarkParent","componentDidUpdate","nextIsOpen","validateProps","onInteraction","POPOVER_WARN_UNCONTROLLED_ONINTERACTION","POPOVER_WARN_HAS_BACKDROP_INLINE","POPOVER_HAS_BACKDROP_INTERACTION","POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX","childrenCount","count","hasRenderTargetProp","hasTargetPropsProp","POPOVER_REQUIRES_TARGET","POPOVER_WARN_TOO_MANY_CHILDREN","POPOVER_WARN_DOUBLE_TARGET","POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET","modifiersCustom","popperModifiers","name","computeStyles","options","adaptive","gpuAcceleration","offset","flip","boundary","rootBoundary","preventOverflow","push","apply","timeout","cancelOpenTimeout","isEscapeKeypressEvent","element","isEmptyString","displayName","defaultProps","key"],"sources":["C:\\Users\\deepa\\Deepak\\Working-File\\React-Project\\new-working-file\\React-Project\\my-app\\node_modules\\@blueprintjs\\core\\src\\components\\popover\\popover.tsx"],"sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { State as PopperState, PositioningStrategy } from \"@popperjs/core\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport {\n    Manager,\n    type Modifier,\n    Popper,\n    type PopperChildrenProps,\n    Reference,\n    type ReferenceChildrenProps,\n} from \"react-popper\";\n\nimport {\n    AbstractPureComponent,\n    Classes,\n    DISPLAYNAME_PREFIX,\n    type HTMLDivProps,\n    mergeRefs,\n    refHandler,\n    Utils,\n} from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { Overlay2 } from \"../overlay2/overlay2\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\n\nimport { matchReferenceWidthModifier } from \"./customModifiers\";\nimport { POPOVER_ARROW_SVG_SIZE, PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverPlacementUtils\";\nimport type {\n    DefaultPopoverTargetHTMLProps,\n    PopoverClickTargetHandlers,\n    PopoverHoverTargetHandlers,\n    PopoverSharedProps,\n} from \"./popoverSharedProps\";\nimport { getBasePlacement, getTransformOrigin } from \"./popperUtils\";\nimport type { PopupKind } from \"./popupKind\";\n\nexport const PopoverInteractionKind = {\n    CLICK: \"click\" as const,\n    CLICK_TARGET_ONLY: \"click-target\" as const,\n    HOVER: \"hover\" as const,\n    HOVER_TARGET_ONLY: \"hover-target\" as const,\n};\nexport type PopoverInteractionKind = (typeof PopoverInteractionKind)[keyof typeof PopoverInteractionKind];\n\nexport interface PopoverProps<TProps extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps>\n    extends PopoverSharedProps<TProps> {\n    /**\n     * Whether the popover/tooltip should acquire application focus when it first opens.\n     *\n     * @default true for click interactions, false for hover interactions\n     */\n    autoFocus?: boolean;\n\n    /** HTML props for the backdrop element. Can be combined with `backdropClassName`. */\n    backdropProps?: React.HTMLProps<HTMLDivElement>;\n\n    /**\n     * The kind of interaction that triggers the display of the popover.\n     *\n     * @default \"click\"\n     */\n    interactionKind?: PopoverInteractionKind;\n\n    /**\n     * The kind of popup displayed by the popover. Gets directly applied to the\n     * `aria-haspopup` attribute of the target element. This property is\n     * ignored if `interactionKind` is {@link PopoverInteractionKind.HOVER_TARGET_ONLY}.\n     *\n     * @default \"menu\" or undefined\n     */\n    popupKind?: PopupKind;\n\n    /**\n     * Enables an invisible overlay beneath the popover that captures clicks and\n     * prevents interaction with the rest of the document until the popover is\n     * closed. This prop is only available when `interactionKind` is\n     * `PopoverInteractionKind.CLICK`. When popovers with backdrop are opened,\n     * they become focused.\n     *\n     * @default false\n     */\n    hasBackdrop?: boolean;\n\n    /**\n     * Whether the application should return focus to the last active element in the\n     * document after this popover closes.\n     *\n     * This is automatically set (overridden) to:\n     *  - `false` for hover interaction popovers\n     *  - `true` when a popover closes due to an ESC keypress\n     *\n     * If you are attaching a popover _and_ a tooltip to the same target, you must take\n     * care to either disable this prop for the popover _or_ disable the tooltip's\n     * `openOnTargetFocus` prop.\n     *\n     * @default false\n     */\n    shouldReturnFocusOnClose?: boolean;\n\n    /**\n     * Popper.js positioning strategy.\n     *\n     * @see https://popper.js.org/docs/v2/constructors/#strategy\n     * @default \"absolute\"\n     */\n    positioningStrategy?: PositioningStrategy;\n}\n\nexport interface PopoverState {\n    hasDarkParent: boolean;\n    // when an ESC keypress interaction closes the overlay, we want to force-enable `shouldReturnFocusOnClose` behavior\n    isClosingViaEscapeKeypress: boolean;\n    isOpen: boolean;\n}\n\n/**\n * Popover component, used to display a floating UI next to and tethered to a target element.\n *\n * @template T target element props interface. Consumers wishing to stay in sync with Blueprint's default target HTML\n * props interface should use the `DefaultPopoverTargetHTMLProps` type (although this is already the default type for\n * this type param).\n * @see https://blueprintjs.com/docs/#core/components/popover\n */\nexport class Popover<\n    T extends DefaultPopoverTargetHTMLProps = DefaultPopoverTargetHTMLProps,\n> extends AbstractPureComponent<PopoverProps<T>, PopoverState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.Popover`;\n\n    public static defaultProps: PopoverProps = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        matchTargetWidth: false,\n        minimal: false,\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` or `position` here because that would trigger\n        // a warning in validateProps if the other prop is specified by a user of this component\n        positioningStrategy: \"absolute\",\n        renderTarget: undefined,\n        shouldReturnFocusOnClose: false,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n\n    public state: PopoverState = {\n        hasDarkParent: false,\n        isClosingViaEscapeKeypress: false,\n        isOpen: this.getIsOpen(this.props),\n    };\n\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     *\n     * @public for testing\n     */\n    public popoverElement: HTMLElement | null = null;\n\n    /** Popover ref handler */\n    private popoverRef: React.RefCallback<HTMLDivElement> = refHandler(this, \"popoverElement\", this.props.popoverRef);\n\n    /**\n     * Target DOM element ref.\n     *\n     * N.B. this must be a ref object since we pass it to `<ResizeSensor>`, which needs to know about the target\n     * DOM element in order to observe its dimensions.\n     *\n     * @public for testing\n     */\n    public targetRef = React.createRef<HTMLElement>();\n\n    /**\n     * Overlay2 transition container element ref.\n     */\n    private transitionContainerElement = React.createRef<HTMLDivElement>();\n\n    private cancelOpenTimeout?: () => void;\n\n    // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n    private isMouseInTargetOrPopover = false;\n\n    // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n    private lostFocusOnSamePage = true;\n\n    // Reference to the Poppper.scheduleUpdate() function, this changes every time the popper is mounted\n    private popperScheduleUpdate?: () => Promise<Partial<PopperState> | null>;\n\n    private isControlled = () => this.props.isOpen !== undefined;\n\n    // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n    private isArrowEnabled = () => !this.props.minimal && this.props.modifiers?.arrow?.enabled !== false;\n\n    private isHoverInteractionKind = () => {\n        return (\n            this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n        );\n    };\n\n    // popper innerRef gives us a handle on the transition container, since that's what we render as the overlay child,\n    // so if we want to look at our actual popover element, we need to reach inside a bit\n    private getPopoverElement() {\n        return this.popoverElement?.querySelector<HTMLElement>(`.${Classes.POPOVER}`);\n    }\n\n    private getIsOpen(props: PopoverProps<T>) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        } else {\n            return props.isOpen ?? props.defaultIsOpen!;\n        }\n    }\n\n    public render() {\n        const { disabled, placement, position = \"auto\", positioningStrategy } = this.props;\n        const { isOpen } = this.state;\n\n        if (this.getIsContentEmpty()) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n\n        // Important: do not use <Reference innerRef> since it has a bug when used in React 18 strict mode\n        // see https://github.com/floating-ui/react-popper/pull/459\n        return (\n            <Manager>\n                <Reference>{this.renderTarget}</Reference>\n                <Popper\n                    innerRef={this.popoverRef}\n                    placement={placement ?? positionToPlacement(position)}\n                    strategy={positioningStrategy}\n                    modifiers={this.getPopperModifiers()}\n                >\n                    {this.renderPopover}\n                </Popper>\n            </Manager>\n        );\n    }\n\n    public componentDidMount() {\n        this.updateDarkParent();\n    }\n\n    public componentDidUpdate(props: PopoverProps<T>, state: PopoverState) {\n        super.componentDidUpdate(props, state);\n        this.updateDarkParent();\n\n        const nextIsOpen = this.getIsOpen(this.props);\n\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    }\n\n    protected validateProps(props: PopoverProps<T>) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.warn(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        if (props.placement !== undefined && props.position !== undefined) {\n            console.warn(Errors.POPOVER_WARN_PLACEMENT_AND_POSITION_MUTEX);\n        }\n\n        const childrenCount = React.Children.count(props.children);\n        const hasRenderTargetProp = props.renderTarget !== undefined;\n        const hasTargetPropsProp = props.targetProps !== undefined;\n\n        if (childrenCount === 0 && !hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (hasRenderTargetProp && hasTargetPropsProp) {\n            console.warn(Errors.POPOVER_WARN_TARGET_PROPS_WITH_RENDER_TARGET);\n        }\n    }\n\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n    public reposition = () => this.popperScheduleUpdate?.();\n\n    private renderTarget = ({ ref: popperChildRef }: ReferenceChildrenProps) => {\n        const { children, className, disabled, fill, openOnTargetFocus, renderTarget } = this.props;\n        const { isOpen } = this.state;\n        const isControlled = this.isControlled();\n        const isHoverInteractionKind = this.isHoverInteractionKind();\n\n        let { targetTagName } = this.props;\n        if (fill) {\n            targetTagName = \"div\";\n        }\n\n        // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n        // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Reference.js#L17\n        const ref = mergeRefs(popperChildRef as React.RefCallback<HTMLElement>, this.targetRef);\n\n        const targetEventHandlers: PopoverHoverTargetHandlers<T> | PopoverClickTargetHandlers<T> =\n            isHoverInteractionKind\n                ? {\n                      // HOVER handlers\n                      onBlur: this.handleTargetBlur,\n                      onContextMenu: this.handleTargetContextMenu,\n                      onFocus: this.handleTargetFocus,\n                      onMouseEnter: this.handleMouseEnter,\n                      onMouseLeave: this.handleMouseLeave,\n                  }\n                : {\n                      // CLICK needs only one handler\n                      onClick: this.handleTargetClick,\n                      // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n                      onKeyDown: this.handleKeyDown,\n                  };\n        // Ensure target is focusable if relevant prop enabled\n        const targetTabIndex =\n            !this.getIsContentEmpty() && !disabled && openOnTargetFocus && isHoverInteractionKind ? 0 : undefined;\n        const ownTargetProps = {\n            // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n            // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n            // applied to the generated target wrapper element.\n            className: classNames(className, Classes.POPOVER_TARGET, {\n                [Classes.POPOVER_OPEN]: isOpen,\n                // this class is mainly useful for button targets\n                [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            }),\n            ref,\n            ...targetEventHandlers,\n        } satisfies React.HTMLProps<HTMLElement>;\n        const childTargetProps = {\n            \"aria-expanded\": isHoverInteractionKind ? undefined : isOpen,\n            \"aria-haspopup\":\n                this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY\n                    ? undefined\n                    : this.props.popupKind ?? \"menu\",\n        } satisfies React.HTMLProps<HTMLElement>;\n\n        const targetModifierClasses = {\n            // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n            // uncontrolled popovers when they are opened by a user interaction\n            [Classes.ACTIVE]: isOpen && !isControlled && !isHoverInteractionKind,\n            // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n            [Classes.FILL]: fill,\n        };\n\n        let target: React.JSX.Element | undefined;\n\n        if (renderTarget !== undefined) {\n            target = renderTarget({\n                ...ownTargetProps,\n                ...childTargetProps,\n                className: classNames(ownTargetProps.className, targetModifierClasses),\n                // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                // when *this* popover is open\n                isOpen,\n                tabIndex: targetTabIndex,\n            });\n        } else {\n            const childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n\n            if (childTarget === undefined) {\n                return null;\n            }\n\n            const clonedTarget: React.JSX.Element = React.cloneElement(childTarget, {\n                ...childTargetProps,\n                className: classNames(childTarget.props.className, targetModifierClasses),\n                // force disable single Tooltip child when popover is open\n                disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip) ? true : childTarget.props.disabled,\n                tabIndex: childTarget.props.tabIndex ?? targetTabIndex,\n            });\n            const wrappedTarget = React.createElement(\n                targetTagName!,\n                {\n                    ...ownTargetProps,\n                    ...this.props.targetProps,\n                },\n                clonedTarget,\n            );\n            target = wrappedTarget;\n        }\n\n        // No need to use the merged `ref` here, that only needs to be forwarded to the child node so that React can\n        // notify both popper.js and our components about the mounted DOM element.\n        return (\n            <ResizeSensor targetRef={this.targetRef} onResize={this.reposition}>\n                {target}\n            </ResizeSensor>\n        );\n    };\n\n    private renderPopover = (popperProps: PopperChildrenProps) => {\n        const { autoFocus, enforceFocus, backdropProps, canEscapeKeyClose, hasBackdrop, interactionKind, usePortal } =\n            this.props;\n        const { isClosingViaEscapeKeypress, isOpen } = this.state;\n\n        // compute an appropriate transform origin so the scale animation points towards target\n        const transformOrigin = getTransformOrigin(\n            popperProps.placement,\n            this.isArrowEnabled() ? (popperProps.arrowProps.style as any) : undefined,\n        );\n\n        // need to update our reference to this function on every render as it will change.\n        this.popperScheduleUpdate = popperProps.update;\n\n        const popoverHandlers: HTMLDivProps = {\n            // always check popover clicks for dismiss class\n            onClick: this.handlePopoverClick,\n            // treat ENTER/SPACE keys the same as a click for accessibility\n            onKeyDown: event => Utils.isKeyboardClick(event) && this.handlePopoverClick(event),\n        };\n        if (\n            interactionKind === PopoverInteractionKind.HOVER ||\n            (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)\n        ) {\n            popoverHandlers.onMouseEnter = this.handleMouseEnter;\n            popoverHandlers.onMouseLeave = this.handleMouseLeave;\n        }\n\n        const basePlacement = getBasePlacement(popperProps.placement);\n        const popoverClasses = classNames(\n            Classes.POPOVER,\n            {\n                [Classes.DARK]: this.props.inheritDarkTheme && this.state.hasDarkParent,\n                [Classes.MINIMAL]: this.props.minimal,\n                [Classes.POPOVER_CAPTURING_DISMISS]: this.props.captureDismiss,\n                [Classes.POPOVER_MATCH_TARGET_WIDTH]: this.props.matchTargetWidth,\n                [Classes.POPOVER_REFERENCE_HIDDEN]: popperProps.isReferenceHidden === true,\n                [Classes.POPOVER_POPPER_ESCAPED]: popperProps.hasPopperEscaped === true,\n            },\n            `${Classes.POPOVER_CONTENT_PLACEMENT}-${basePlacement}`,\n            this.props.popoverClassName,\n        );\n\n        const defaultAutoFocus = this.isHoverInteractionKind() ? false : undefined;\n        // if hover interaction, it doesn't make sense to take over focus control\n        const shouldReturnFocusOnClose = this.isHoverInteractionKind()\n            ? false\n            : isClosingViaEscapeKeypress\n              ? true\n              : this.props.shouldReturnFocusOnClose;\n\n        return (\n            <Overlay2\n                autoFocus={autoFocus ?? defaultAutoFocus}\n                backdropClassName={Classes.POPOVER_BACKDROP}\n                backdropProps={backdropProps}\n                canEscapeKeyClose={canEscapeKeyClose}\n                canOutsideClickClose={interactionKind === PopoverInteractionKind.CLICK}\n                childRef={this.transitionContainerElement}\n                enforceFocus={enforceFocus}\n                hasBackdrop={hasBackdrop}\n                isOpen={isOpen}\n                lazy={this.props.lazy}\n                onClose={this.handleOverlayClose}\n                onClosed={this.props.onClosed}\n                onClosing={this.props.onClosing}\n                onOpened={this.props.onOpened}\n                onOpening={this.props.onOpening}\n                transitionDuration={this.props.transitionDuration}\n                transitionName={Classes.POPOVER}\n                usePortal={usePortal}\n                portalClassName={this.props.portalClassName}\n                portalContainer={this.props.portalContainer}\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                portalStopPropagationEvents={this.props.portalStopPropagationEvents}\n                shouldReturnFocusOnClose={shouldReturnFocusOnClose}\n            >\n                <div\n                    className={Classes.POPOVER_TRANSITION_CONTAINER}\n                    // We need to attach a ref that notifies both react-popper and our Popover component about the DOM\n                    // element inside the Overlay2. We cannot re-use `PopperChildrenProps.ref` because Overlay2 only\n                    // accepts a ref object (not a callback) due to a CSSTransition API limitation.\n                    // N.B. react-popper has a wide type for this ref, but we can narrow it based on the source,\n                    // see https://github.com/floating-ui/react-popper/blob/beac280d61082852c4efc302be902911ce2d424c/src/Popper.js#L94\n                    ref={mergeRefs(popperProps.ref as React.RefCallback<HTMLElement>, this.transitionContainerElement)}\n                    style={popperProps.style}\n                >\n                    <ResizeSensor onResize={this.reposition}>\n                        <div\n                            className={popoverClasses}\n                            style={{ transformOrigin }}\n                            ref={this.popoverRef}\n                            {...popoverHandlers}\n                        >\n                            {this.isArrowEnabled() && (\n                                <PopoverArrow arrowProps={popperProps.arrowProps} placement={popperProps.placement} />\n                            )}\n                            <div className={Classes.POPOVER_CONTENT}>{this.props.content}</div>\n                        </div>\n                    </ResizeSensor>\n                </div>\n            </Overlay2>\n        );\n    };\n\n    private getPopperModifiers(): ReadonlyArray<Modifier<any>> {\n        const { matchTargetWidth, modifiers, modifiersCustom } = this.props;\n        const popperModifiers: Array<Modifier<any>> = [\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"arrow\",\n                ...modifiers?.arrow,\n            },\n            {\n                name: \"computeStyles\",\n                ...modifiers?.computeStyles,\n                options: {\n                    adaptive: true,\n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false,\n                    ...modifiers?.computeStyles?.options,\n                },\n            },\n            {\n                enabled: this.isArrowEnabled(),\n                name: \"offset\",\n                ...modifiers?.offset,\n                options: {\n                    offset: [0, POPOVER_ARROW_SVG_SIZE / 2],\n                    ...modifiers?.offset?.options,\n                },\n            },\n            {\n                name: \"flip\",\n                ...modifiers?.flip,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.flip?.options,\n                },\n            },\n            {\n                name: \"preventOverflow\",\n                ...modifiers?.preventOverflow,\n                options: {\n                    boundary: this.props.boundary,\n                    rootBoundary: this.props.rootBoundary,\n                    ...modifiers?.preventOverflow?.options,\n                },\n            },\n        ];\n\n        if (matchTargetWidth) {\n            popperModifiers.push(matchReferenceWidthModifier);\n        }\n\n        if (modifiersCustom !== undefined) {\n            popperModifiers.push(...modifiersCustom);\n        }\n\n        return popperModifiers;\n    }\n\n    private handleTargetFocus = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget == null && !this.lostFocusOnSamePage) {\n                // ignore this focus event -- the target was already focused but the page itself\n                // lost focus (e.g. due to switching tabs).\n                return;\n            }\n            this.handleMouseEnter(e as unknown as React.MouseEvent<HTMLElement>);\n        }\n    };\n\n    private handleTargetBlur = (e: React.FocusEvent<HTMLElement>) => {\n        if (this.props.openOnTargetFocus && this.isHoverInteractionKind()) {\n            if (e.relatedTarget != null) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open.\n                if (\n                    e.relatedTarget !== this.popoverElement &&\n                    !this.isElementInPopover(e.relatedTarget as HTMLElement)\n                ) {\n                    this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n                }\n            } else {\n                this.handleMouseLeave(e as unknown as React.MouseEvent<HTMLElement>);\n            }\n        }\n        this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    private handleTargetContextMenu = (e: React.MouseEvent<HTMLElement>) => {\n        // we assume that when someone prevents the default interaction on this event (a browser native context menu),\n        // they are showing a custom context menu (as ContextMenu2 does); in this case, we should close this popover/tooltip\n        if (e.defaultPrevented) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleMouseEnter = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = true;\n\n        // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n        // trigger the mouse leave event, as hovering over the popover shouldn't count.\n        if (\n            !this.props.usePortal &&\n            this.isElementInPopover(e.target as Element) &&\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n            !this.props.openOnTargetFocus\n        ) {\n            this.handleMouseLeave(e);\n        } else if (!this.props.disabled) {\n            // only begin opening popover when it is enabled\n            this.setOpenState(true, e, this.props.hoverOpenDelay);\n        }\n    };\n\n    private handleMouseLeave = (e: React.MouseEvent<HTMLElement>) => {\n        this.isMouseInTargetOrPopover = false;\n\n        // Wait until the event queue is flushed, because we want to leave the\n        // popover open if the mouse entered the popover immediately after\n        // leaving the target (or vice versa). Make sure to persist the event since\n        // we need to access `nativeEvent` in `this.setOpenState()`.\n        e.persist();\n        this.setTimeout(() => {\n            if (this.isMouseInTargetOrPopover) {\n                return;\n            }\n            // user-configurable closing delay is helpful when moving mouse from target to popover\n            this.setOpenState(false, e, this.props.hoverCloseDelay);\n        });\n    };\n\n    private handlePopoverClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        const eventTarget = e.target as HTMLElement;\n        const eventPopover = eventTarget.closest(`.${Classes.POPOVER}`);\n        const eventPopoverV1 = eventTarget.closest(`.${Classes.POPOVER}`);\n        const isEventFromSelf = (eventPopover ?? eventPopoverV1) === this.getPopoverElement();\n\n        const isEventPopoverCapturing =\n            eventPopover?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            eventPopoverV1?.classList.contains(Classes.POPOVER_CAPTURING_DISMISS) ??\n            false;\n\n        // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n        const dismissElement = eventTarget.closest(`.${Classes.POPOVER_DISMISS}, .${Classes.POPOVER_DISMISS_OVERRIDE}`);\n        const shouldDismiss = dismissElement?.classList.contains(Classes.POPOVER_DISMISS) ?? false;\n        const isDisabled = eventTarget.closest(`:disabled, .${Classes.DISABLED}`) != null;\n\n        if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleOverlayClose = (e?: React.SyntheticEvent<HTMLElement>) => {\n        if (this.targetRef.current == null || e === undefined) {\n            return;\n        }\n\n        const event = (e.nativeEvent ?? e) as Event;\n        const eventTarget = (event.composed ? event.composedPath()[0] : event.target) as HTMLElement;\n        // if click was in target, target event listener will handle things, so don't close\n        if (!Utils.elementIsOrContains(this.targetRef.current, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n            this.setOpenState(false, e);\n        }\n    };\n\n    private handleKeyDown = (e: React.KeyboardEvent<HTMLElement>) => {\n        const isKeyboardClick = Utils.isKeyboardClick(e);\n\n        // For keyboard accessibility, trigger the same behavior as a click event upon pressing ENTER/SPACE\n        if (isKeyboardClick) {\n            this.handleTargetClick(e);\n        }\n    };\n\n    private handleTargetClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        // Target element(s) may fire simulated click event upon pressing ENTER/SPACE, which we should ignore\n        // see: https://github.com/palantir/blueprint/issues/5775\n        const shouldIgnoreClick = this.state.isOpen && this.isSimulatedButtonClick(e);\n        if (!shouldIgnoreClick) {\n            // ensure click did not originate from within inline popover before closing\n            if (!this.props.disabled && !this.isElementInPopover(e.target as HTMLElement)) {\n                if (this.props.isOpen == null) {\n                    this.setState(prevState => ({ isOpen: !prevState.isOpen }));\n                } else {\n                    this.setOpenState(!this.props.isOpen, e);\n                }\n            }\n        }\n    };\n\n    private isSimulatedButtonClick = (e: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        return !e.isTrusted && (e.target as HTMLElement).matches(`.${Classes.BUTTON}`);\n    };\n\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    private setOpenState(isOpen: boolean, e?: React.SyntheticEvent<HTMLElement>, timeout?: number) {\n        // cancel any existing timeout because we have new state\n        this.cancelOpenTimeout?.();\n        if (timeout !== undefined && timeout > 0) {\n            // Persist the react event since it will be used in a later macrotask.\n            e?.persist();\n            this.cancelOpenTimeout = this.setTimeout(() => {\n                this.setOpenState(isOpen, e);\n            }, timeout);\n        } else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen });\n            } else {\n                this.props.onInteraction?.(isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                this.props.onClose?.(e!);\n                this.setState({ isClosingViaEscapeKeypress: isEscapeKeypressEvent(e?.nativeEvent) });\n            }\n        }\n    }\n\n    private updateDarkParent() {\n        if (this.props.usePortal && this.state.isOpen) {\n            const hasDarkParent = this.targetRef.current?.closest(`.${Classes.DARK}`) != null;\n            this.setState({ hasDarkParent });\n        }\n    }\n\n    private isElementInPopover(element: Element) {\n        return this.getPopoverElement()?.contains(element) ?? false;\n    }\n\n    private getIsContentEmpty() {\n        const { content } = this.props;\n        return content == null || Utils.isEmptyString(content);\n    }\n}\n\nfunction isEscapeKeypressEvent(e?: Event) {\n    return e instanceof KeyboardEvent && e.key === \"Escape\";\n}\n\nfunction noop() {\n    // no-op\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}