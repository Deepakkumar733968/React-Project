{"ast":null,"code":"/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\nimport { useUID } from \"react-uid\";\nimport { Classes, mergeRefs } from \"../../common\";\nimport { OVERLAY_CHILD_REF_AND_REFS_MUTEX, OVERLAY_CHILD_REQUIRES_KEY, OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { ensureElement, getActiveElement, getRef, isEmptyString, isNodeEnv, isReactElement, setRef } from \"../../common/utils\";\nimport { hasDOMEnvironment } from \"../../common/utils/domUtils\";\nimport { useOverlayStack } from \"../../hooks/overlays/useOverlayStack\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport { getKeyboardFocusableElements } from \"../overlay/overlayUtils\";\nimport { Portal } from \"../portal/portal\";\nexport var OVERLAY2_DEFAULT_PROPS = {\n  autoFocus: true,\n  backdropProps: {},\n  canEscapeKeyClose: true,\n  canOutsideClickClose: true,\n  enforceFocus: true,\n  hasBackdrop: true,\n  isOpen: false,\n  lazy: hasDOMEnvironment(),\n  shouldReturnFocusOnClose: true,\n  transitionDuration: 300,\n  transitionName: Classes.OVERLAY,\n  usePortal: true\n};\n/**\n * Overlay2 component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overlay2\n */\nexport var Overlay2 = React.forwardRef(function (props, forwardedRef) {\n  var _a;\n  var _b, _c;\n  var autoFocus = props.autoFocus,\n    backdropClassName = props.backdropClassName,\n    backdropProps = props.backdropProps,\n    canEscapeKeyClose = props.canEscapeKeyClose,\n    canOutsideClickClose = props.canOutsideClickClose,\n    childRef = props.childRef,\n    childRefs = props.childRefs,\n    children = props.children,\n    className = props.className,\n    enforceFocus = props.enforceFocus,\n    hasBackdrop = props.hasBackdrop,\n    isOpen = props.isOpen,\n    lazy = props.lazy,\n    onClose = props.onClose,\n    onClosed = props.onClosed,\n    onClosing = props.onClosing,\n    onOpened = props.onOpened,\n    onOpening = props.onOpening,\n    portalClassName = props.portalClassName,\n    portalContainer = props.portalContainer,\n    shouldReturnFocusOnClose = props.shouldReturnFocusOnClose,\n    transitionDuration = props.transitionDuration,\n    transitionName = props.transitionName,\n    usePortal = props.usePortal;\n  useOverlay2Validation(props);\n  var _d = useOverlayStack(),\n    closeOverlay = _d.closeOverlay,\n    getLastOpened = _d.getLastOpened,\n    getThisOverlayAndDescendants = _d.getThisOverlayAndDescendants,\n    openOverlay = _d.openOverlay;\n  var _e = React.useState(false),\n    isAutoFocusing = _e[0],\n    setIsAutoFocusing = _e[1];\n  var _f = React.useState(false),\n    hasEverOpened = _f[0],\n    setHasEverOpened = _f[1];\n  var lastActiveElementBeforeOpened = React.useRef(null);\n  /** Ref for container element, containing all children and the backdrop */\n  var containerElement = React.useRef(null);\n  /** Ref for backdrop element */\n  var backdropElement = React.useRef(null);\n  /* An empty, keyboard-focusable div at the beginning of the Overlay content */\n  var startFocusTrapElement = React.useRef(null);\n  /* An empty, keyboard-focusable div at the end of the Overlay content */\n  var endFocusTrapElement = React.useRef(null);\n  /**\n   * Locally-generated DOM ref for a singleton child element.\n   * This is only used iff the user does not specify the `childRef` or `childRefs` props.\n   */\n  var localChildRef = React.useRef(null);\n  var bringFocusInsideOverlay = React.useCallback(function () {\n    // always delay focus manipulation to just before repaint to prevent scroll jumping\n    return requestAnimationFrame(function () {\n      var _a;\n      // container element may be undefined between component mounting and Portal rendering\n      // activeElement may be undefined in some rare cases in IE\n      var container = getRef(containerElement);\n      var activeElement = getActiveElement(container);\n      if (container == null || activeElement == null) {\n        return;\n      }\n      // Overlay2 is guaranteed to be mounted here\n      var isFocusOutsideModal = !container.contains(activeElement);\n      if (isFocusOutsideModal) {\n        (_a = getRef(startFocusTrapElement)) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n        setIsAutoFocusing(false);\n      }\n    });\n  }, []);\n  /** Unique ID for this overlay in the global stack */\n  var id = useOverlay2ID();\n  // N.B. use `null` here and not simply `undefined` because `useImperativeHandle` will set `null` on unmount,\n  // and we need the following code to be resilient to that value.\n  var instance = React.useRef(null);\n  /**\n   * When multiple `enforceFocus` Overlays are open, this event handler is only active for the most\n   * recently opened one to avoid Overlays competing with each other for focus.\n   */\n  var handleDocumentFocus = React.useCallback(function (e) {\n    // get the actual target even in the Shadow DOM\n    // see https://github.com/palantir/blueprint/issues/4220\n    var eventTarget = e.composed ? e.composedPath()[0] : e.target;\n    var container = getRef(containerElement);\n    if (container != null && eventTarget instanceof Node && !container.contains(eventTarget)) {\n      // prevent default focus behavior (sometimes auto-scrolls the page)\n      e.preventDefault();\n      e.stopImmediatePropagation();\n      bringFocusInsideOverlay();\n    }\n  }, [bringFocusInsideOverlay]);\n  // N.B. this listener is only kept attached when `isOpen={true}` and `canOutsideClickClose={true}`\n  var handleDocumentMousedown = React.useCallback(function (e) {\n    // get the actual target even in the Shadow DOM\n    // see https://github.com/palantir/blueprint/issues/4220\n    var eventTarget = e.composed ? e.composedPath()[0] : e.target;\n    var thisOverlayAndDescendants = getThisOverlayAndDescendants(id);\n    var isClickInThisOverlayOrDescendant = thisOverlayAndDescendants.some(function (_a) {\n      var containerRef = _a.containerElement;\n      // `elem` is the container of backdrop & content, so clicking directly on that container\n      // should not count as being \"inside\" the overlay.\n      var elem = getRef(containerRef);\n      return (elem === null || elem === void 0 ? void 0 : elem.contains(eventTarget)) && !elem.isSameNode(eventTarget);\n    });\n    if (!isClickInThisOverlayOrDescendant) {\n      // casting to any because this is a native event\n      onClose === null || onClose === void 0 ? void 0 : onClose(e);\n    }\n  }, [getThisOverlayAndDescendants, id, onClose]);\n  // send this instance's imperative handle to the the forwarded ref as well as our local ref\n  var ref = React.useMemo(function () {\n    return mergeRefs(forwardedRef, instance);\n  }, [forwardedRef]);\n  React.useImperativeHandle(ref, function () {\n    return {\n      bringFocusInsideOverlay: bringFocusInsideOverlay,\n      containerElement: containerElement,\n      handleDocumentFocus: handleDocumentFocus,\n      handleDocumentMousedown: handleDocumentMousedown,\n      id: id,\n      props: {\n        autoFocus: autoFocus,\n        enforceFocus: enforceFocus,\n        hasBackdrop: hasBackdrop,\n        usePortal: usePortal\n      }\n    };\n  }, [autoFocus, bringFocusInsideOverlay, enforceFocus, handleDocumentFocus, handleDocumentMousedown, hasBackdrop, id, usePortal]);\n  var handleContainerKeyDown = React.useCallback(function (e) {\n    if (e.key === \"Escape\" && canEscapeKeyClose) {\n      onClose === null || onClose === void 0 ? void 0 : onClose(e);\n      // prevent other overlays from closing\n      e.stopPropagation();\n      // prevent browser-specific escape key behavior (Safari exits fullscreen)\n      e.preventDefault();\n    }\n  }, [canEscapeKeyClose, onClose]);\n  var overlayWillOpen = React.useCallback(function () {\n    if (instance.current == null) {\n      return;\n    }\n    var lastOpenedOverlay = getLastOpened();\n    if ((lastOpenedOverlay === null || lastOpenedOverlay === void 0 ? void 0 : lastOpenedOverlay.handleDocumentFocus) !== undefined) {\n      document.removeEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */true);\n    }\n    openOverlay(instance.current);\n    if (autoFocus) {\n      setIsAutoFocusing(true);\n      bringFocusInsideOverlay();\n    }\n    setRef(lastActiveElementBeforeOpened, getActiveElement(getRef(containerElement)));\n  }, [autoFocus, bringFocusInsideOverlay, getLastOpened, openOverlay]);\n  var overlayWillClose = React.useCallback(function () {\n    var _a;\n    document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */true);\n    document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n    // N.B. `instance.current` may be null at this point if we are cleaning up an open overlay during the unmount phase\n    // (this is common, for example, with context menu's singleton `showContextMenu` / `hideContextMenu` imperative APIs).\n    closeOverlay(id);\n    var lastOpenedOverlay = getLastOpened();\n    if (lastOpenedOverlay !== undefined) {\n      // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n      // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n      // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n      if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n        (_a = lastOpenedOverlay.bringFocusInsideOverlay) === null || _a === void 0 ? void 0 : _a.call(lastOpenedOverlay);\n        if (lastOpenedOverlay.handleDocumentFocus !== undefined) {\n          document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */true);\n        }\n      }\n    }\n  }, [closeOverlay, getLastOpened, handleDocumentFocus, handleDocumentMousedown, id]);\n  var prevIsOpen = (_b = usePrevious(isOpen)) !== null && _b !== void 0 ? _b : false;\n  React.useEffect(function () {\n    if (isOpen) {\n      setHasEverOpened(true);\n    }\n    if (!prevIsOpen && isOpen) {\n      // just opened\n      overlayWillOpen();\n    }\n    if (prevIsOpen && !isOpen) {\n      // just closed\n      overlayWillClose();\n    }\n  }, [isOpen, overlayWillOpen, overlayWillClose, prevIsOpen]);\n  // Important: clean up old document-level event listeners if their memoized values change (this is rare, but\n  // may happen, for example, if a user forgets to use `React.useCallback` in the `props.onClose` value).\n  // Otherwise, we will lose the reference to those values and create a memory leak since we won't be able\n  // to successfully detach them inside overlayWillClose.\n  React.useEffect(function () {\n    if (!isOpen || !(canOutsideClickClose && !hasBackdrop)) {\n      return;\n    }\n    document.addEventListener(\"mousedown\", handleDocumentMousedown);\n    return function () {\n      document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n    };\n  }, [handleDocumentMousedown, isOpen, canOutsideClickClose, hasBackdrop]);\n  React.useEffect(function () {\n    if (!isOpen || !enforceFocus) {\n      return;\n    }\n    // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n    // our handler before all others\n    document.addEventListener(\"focus\", handleDocumentFocus, /* useCapture */true);\n    return function () {\n      document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */true);\n    };\n  }, [handleDocumentFocus, enforceFocus, isOpen]);\n  var overlayWillCloseRef = React.useRef(overlayWillClose);\n  overlayWillCloseRef.current = overlayWillClose;\n  React.useEffect(function () {\n    // run cleanup code once on unmount, ensuring we call the most recent overlayWillClose callback\n    // by storing in a ref and keeping up to date\n    return function () {\n      overlayWillCloseRef.current();\n    };\n  }, []);\n  var handleTransitionExited = React.useCallback(function (node) {\n    var lastActiveElement = getRef(lastActiveElementBeforeOpened);\n    if (shouldReturnFocusOnClose && lastActiveElement instanceof HTMLElement) {\n      lastActiveElement.focus();\n    }\n    onClosed === null || onClosed === void 0 ? void 0 : onClosed(node);\n  }, [onClosed, shouldReturnFocusOnClose]);\n  // N.B. CSSTransition requires this callback to be defined, even if it's unused.\n  var handleTransitionAddEnd = React.useCallback(function () {\n    // no-op\n  }, []);\n  /**\n   * Gets the relevant DOM ref for a child element using the `childRef` or `childRefs` props (if possible).\n   * This ref is necessary for `CSSTransition` to work in React 18 without relying on `ReactDOM.findDOMNode`.\n   *\n   * Returns `undefined` if the user did not specify either of those props. In those cases, we use the ref we\n   * have locally generated and expect that the user _did not_ specify their own `ref` on the child element\n   * (it will get clobbered / overriden).\n   *\n   * @see https://reactcommunity.org/react-transition-group/css-transition\n   */\n  var getUserChildRef = React.useCallback(function (child) {\n    if (childRef != null) {\n      return childRef;\n    } else if (childRefs != null) {\n      var key = child.key;\n      if (key == null) {\n        if (!isNodeEnv(\"production\")) {\n          console.error(OVERLAY_CHILD_REQUIRES_KEY);\n        }\n        return undefined;\n      }\n      return childRefs[key];\n    }\n    return undefined;\n  }, [childRef, childRefs]);\n  var maybeRenderChild = React.useCallback(function (child) {\n    if (child == null || isEmptyString(child)) {\n      return null;\n    }\n    // decorate the child with a few injected props\n    var userChildRef = getUserChildRef(child);\n    var childProps = isReactElement(child) ? child.props : {};\n    // if the child is a string, number, or fragment, it will be wrapped in a <span> element\n    var decoratedChild = ensureElement(child, \"span\", {\n      className: classNames(childProps.className, Classes.OVERLAY_CONTENT),\n      // IMPORTANT: only inject our ref if the user didn't specify childRef or childRefs already. Otherwise,\n      // we risk clobbering the user's ref (which we cannot inspect here while cloning/decorating the child).\n      ref: userChildRef === undefined ? localChildRef : undefined,\n      tabIndex: enforceFocus || autoFocus ? 0 : undefined\n    });\n    var resolvedChildRef = userChildRef !== null && userChildRef !== void 0 ? userChildRef : localChildRef;\n    return React.createElement(CSSTransition, {\n      addEndListener: handleTransitionAddEnd,\n      classNames: transitionName,\n      // HACKHACK: CSSTransition types are slightly incompatible with React types here.\n      // React prefers `| null` but not `| undefined` for the ref value, while\n      // CSSTransition _demands_ that `| undefined` be part of the element type.\n      nodeRef: resolvedChildRef,\n      onEntered: getLifecycleCallbackWithChildRef(onOpened, resolvedChildRef),\n      onEntering: getLifecycleCallbackWithChildRef(onOpening, resolvedChildRef),\n      onExited: getLifecycleCallbackWithChildRef(handleTransitionExited, resolvedChildRef),\n      onExiting: getLifecycleCallbackWithChildRef(onClosing, resolvedChildRef),\n      timeout: transitionDuration\n    }, decoratedChild);\n  }, [autoFocus, enforceFocus, getUserChildRef, handleTransitionAddEnd, handleTransitionExited, onClosing, onOpened, onOpening, transitionDuration, transitionName]);\n  var handleBackdropMouseDown = React.useCallback(function (e) {\n    var _a;\n    if (canOutsideClickClose) {\n      onClose === null || onClose === void 0 ? void 0 : onClose(e);\n    }\n    if (enforceFocus) {\n      bringFocusInsideOverlay();\n    }\n    (_a = backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.onMouseDown) === null || _a === void 0 ? void 0 : _a.call(backdropProps, e);\n  }, [backdropProps, bringFocusInsideOverlay, canOutsideClickClose, enforceFocus, onClose]);\n  var renderDummyElement = React.useCallback(function (key, dummyElementProps) {\n    return React.createElement(CSSTransition, {\n      addEndListener: handleTransitionAddEnd,\n      classNames: transitionName,\n      key: key,\n      nodeRef: dummyElementProps.ref,\n      timeout: transitionDuration,\n      unmountOnExit: true\n    }, React.createElement(\"div\", __assign({\n      tabIndex: 0\n    }, dummyElementProps)));\n  }, [handleTransitionAddEnd, transitionDuration, transitionName]);\n  /**\n   * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n   * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n   * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n   * Overlay.\n   */\n  var handleStartFocusTrapElementFocus = React.useCallback(function (e) {\n    if (!enforceFocus || isAutoFocusing) {\n      return;\n    }\n    // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n    // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n    // Otherwise, we're handling a user interaction, and we should wrap around to the last\n    // element in this transition group.\n    var container = getRef(containerElement);\n    var endFocusTrap = getRef(endFocusTrapElement);\n    if (e.relatedTarget != null && (container === null || container === void 0 ? void 0 : container.contains(e.relatedTarget)) && e.relatedTarget !== endFocusTrap) {\n      endFocusTrap === null || endFocusTrap === void 0 ? void 0 : endFocusTrap.focus({\n        preventScroll: true\n      });\n    }\n  }, [enforceFocus, isAutoFocusing]);\n  /**\n   * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n   */\n  var handleStartFocusTrapElementKeyDown = React.useCallback(function (e) {\n    var _a;\n    if (!enforceFocus) {\n      return;\n    }\n    if (e.shiftKey && e.key === \"Tab\") {\n      var lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n      if (lastFocusableElement != null) {\n        lastFocusableElement.focus();\n      } else {\n        (_a = getRef(endFocusTrapElement)) === null || _a === void 0 ? void 0 : _a.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [enforceFocus]);\n  /**\n   * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n   * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n   * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n   * Overlay.\n   */\n  var handleEndFocusTrapElementFocus = React.useCallback(function (e) {\n    var _a;\n    // No need for this.props.enforceFocus check here because this element is only rendered\n    // when that prop is true.\n    // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n    // \"start focus trap\" element.\n    // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n    // presses shift+tab from the first focusable element in the overlay.\n    var startFocusTrap = getRef(startFocusTrapElement);\n    if (e.relatedTarget != null && ((_a = getRef(containerElement)) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) && e.relatedTarget !== startFocusTrap) {\n      var firstFocusableElement = getKeyboardFocusableElements(containerElement).shift();\n      // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n      if (!isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n        firstFocusableElement.focus();\n      } else {\n        startFocusTrap === null || startFocusTrap === void 0 ? void 0 : startFocusTrap.focus({\n          preventScroll: true\n        });\n      }\n    } else {\n      var lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n      if (lastFocusableElement != null) {\n        lastFocusableElement.focus();\n      } else {\n        // Keeps focus within Overlay even if there are no keyboard-focusable children\n        startFocusTrap === null || startFocusTrap === void 0 ? void 0 : startFocusTrap.focus({\n          preventScroll: true\n        });\n      }\n    }\n  }, [isAutoFocusing]);\n  var maybeBackdrop = React.useMemo(function () {\n    return hasBackdrop && isOpen ? React.createElement(CSSTransition, {\n      classNames: transitionName,\n      key: \"__backdrop\",\n      nodeRef: backdropElement,\n      timeout: transitionDuration,\n      addEndListener: handleTransitionAddEnd\n    }, React.createElement(\"div\", __assign({}, backdropProps, {\n      className: classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps === null || backdropProps === void 0 ? void 0 : backdropProps.className),\n      onMouseDown: handleBackdropMouseDown,\n      ref: backdropElement\n    }))) : null;\n  }, [backdropClassName, backdropProps, handleBackdropMouseDown, handleTransitionAddEnd, hasBackdrop, isOpen, transitionDuration, transitionName]);\n  // no reason to render anything at all if we're being truly lazy\n  if (lazy && !hasEverOpened) {\n    return null;\n  }\n  // TransitionGroup types require single array of children; does not support nested arrays.\n  // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n  // Transition element (no ReactText allowed).\n  var childrenWithTransitions = isOpen ? (_c = React.Children.map(children, maybeRenderChild)) !== null && _c !== void 0 ? _c : [] : [];\n  // const maybeBackdrop = maybeRenderBackdrop();\n  if (maybeBackdrop !== null) {\n    childrenWithTransitions.unshift(maybeBackdrop);\n  }\n  if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n    childrenWithTransitions.unshift(renderDummyElement(\"__start\", {\n      className: Classes.OVERLAY_START_FOCUS_TRAP,\n      onFocus: handleStartFocusTrapElementFocus,\n      onKeyDown: handleStartFocusTrapElementKeyDown,\n      ref: startFocusTrapElement\n    }));\n    if (enforceFocus) {\n      childrenWithTransitions.push(renderDummyElement(\"__end\", {\n        className: Classes.OVERLAY_END_FOCUS_TRAP,\n        onFocus: handleEndFocusTrapElementFocus,\n        ref: endFocusTrapElement\n      }));\n    }\n  }\n  var transitionGroup = React.createElement(\"div\", {\n    \"aria-live\": \"polite\",\n    className: classNames(Classes.OVERLAY, (_a = {}, _a[Classes.OVERLAY_OPEN] = isOpen, _a[Classes.OVERLAY_INLINE] = !usePortal, _a), className),\n    onKeyDown: handleContainerKeyDown,\n    ref: containerElement\n  }, React.createElement(TransitionGroup, {\n    appear: true,\n    component: null\n  }, childrenWithTransitions));\n  if (usePortal) {\n    return React.createElement(Portal, {\n      className: portalClassName,\n      container: portalContainer\n    }, transitionGroup);\n  } else {\n    return transitionGroup;\n  }\n});\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nOverlay2.defaultProps = OVERLAY2_DEFAULT_PROPS;\nOverlay2.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".Overlay2\");\nfunction useOverlay2Validation(_a) {\n  var childRef = _a.childRef,\n    childRefs = _a.childRefs,\n    children = _a.children;\n  var numChildren = React.Children.count(children);\n  React.useEffect(function () {\n    if (isNodeEnv(\"production\")) {\n      return;\n    }\n    if (childRef != null && childRefs != null) {\n      console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX);\n    }\n    if (numChildren > 1 && childRefs == null) {\n      console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS);\n    }\n  }, [childRef, childRefs, numChildren]);\n}\n/**\n * Generates a unique ID for a given Overlay which persists across the component's lifecycle.\n */\nfunction useOverlay2ID() {\n  // TODO: migrate to React.useId() in React 18\n  var id = useUID();\n  return \"\".concat(Overlay2.displayName, \"-\").concat(id);\n}\n// N.B. the `onExiting` callback is not provided with the `node` argument as suggested in CSSTransition types since\n// we are using the `nodeRef` prop, so we must inject it dynamically.\nfunction getLifecycleCallbackWithChildRef(callback, childRef) {\n  return function () {\n    if ((childRef === null || childRef === void 0 ? void 0 : childRef.current) != null) {\n      callback === null || callback === void 0 ? void 0 : callback(childRef.current);\n    }\n  };\n}","map":{"version":3,"names":["classNames","React","CSSTransition","TransitionGroup","useUID","Classes","mergeRefs","OVERLAY_CHILD_REF_AND_REFS_MUTEX","OVERLAY_CHILD_REQUIRES_KEY","OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS","DISPLAYNAME_PREFIX","ensureElement","getActiveElement","getRef","isEmptyString","isNodeEnv","isReactElement","setRef","hasDOMEnvironment","useOverlayStack","usePrevious","getKeyboardFocusableElements","Portal","OVERLAY2_DEFAULT_PROPS","autoFocus","backdropProps","canEscapeKeyClose","canOutsideClickClose","enforceFocus","hasBackdrop","isOpen","lazy","shouldReturnFocusOnClose","transitionDuration","transitionName","OVERLAY","usePortal","Overlay2","forwardRef","props","forwardedRef","backdropClassName","childRef","childRefs","children","className","onClose","onClosed","onClosing","onOpened","onOpening","portalClassName","portalContainer","useOverlay2Validation","_d","closeOverlay","getLastOpened","getThisOverlayAndDescendants","openOverlay","_e","useState","isAutoFocusing","setIsAutoFocusing","_f","hasEverOpened","setHasEverOpened","lastActiveElementBeforeOpened","useRef","containerElement","backdropElement","startFocusTrapElement","endFocusTrapElement","localChildRef","bringFocusInsideOverlay","useCallback","requestAnimationFrame","container","activeElement","isFocusOutsideModal","contains","_a","focus","preventScroll","id","useOverlay2ID","instance","handleDocumentFocus","e","eventTarget","composed","composedPath","target","Node","preventDefault","stopImmediatePropagation","handleDocumentMousedown","thisOverlayAndDescendants","isClickInThisOverlayOrDescendant","some","containerRef","elem","isSameNode","ref","useMemo","useImperativeHandle","handleContainerKeyDown","key","stopPropagation","overlayWillOpen","current","lastOpenedOverlay","undefined","document","removeEventListener","overlayWillClose","call","addEventListener","prevIsOpen","_b","useEffect","overlayWillCloseRef","handleTransitionExited","node","lastActiveElement","HTMLElement","handleTransitionAddEnd","getUserChildRef","child","console","error","maybeRenderChild","userChildRef","childProps","decoratedChild","OVERLAY_CONTENT","tabIndex","resolvedChildRef","createElement","addEndListener","nodeRef","onEntered","getLifecycleCallbackWithChildRef","onEntering","onExited","onExiting","timeout","handleBackdropMouseDown","onMouseDown","renderDummyElement","dummyElementProps","unmountOnExit","__assign","handleStartFocusTrapElementFocus","endFocusTrap","relatedTarget","handleStartFocusTrapElementKeyDown","shiftKey","lastFocusableElement","pop","handleEndFocusTrapElementFocus","startFocusTrap","firstFocusableElement","shift","maybeBackdrop","OVERLAY_BACKDROP","childrenWithTransitions","_c","Children","map","unshift","length","OVERLAY_START_FOCUS_TRAP","onFocus","onKeyDown","push","OVERLAY_END_FOCUS_TRAP","transitionGroup","OVERLAY_OPEN","OVERLAY_INLINE","appear","component","defaultProps","displayName","concat","numChildren","count","callback"],"sources":["C:\\Users\\deepa\\Deepak\\Working-File\\React-Project\\new-working-file\\React-Project\\my-app\\node_modules\\@blueprintjs\\core\\src\\components\\overlay2\\overlay2.tsx"],"sourcesContent":["/*\n * Copyright 2024 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { CSSTransition, TransitionGroup } from \"react-transition-group\";\nimport { useUID } from \"react-uid\";\n\nimport { Classes, mergeRefs } from \"../../common\";\nimport {\n    OVERLAY_CHILD_REF_AND_REFS_MUTEX,\n    OVERLAY_CHILD_REQUIRES_KEY,\n    OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS,\n} from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX, type HTMLDivProps } from \"../../common/props\";\nimport {\n    ensureElement,\n    getActiveElement,\n    getRef,\n    isEmptyString,\n    isNodeEnv,\n    isReactElement,\n    setRef,\n} from \"../../common/utils\";\nimport { hasDOMEnvironment } from \"../../common/utils/domUtils\";\nimport { useOverlayStack } from \"../../hooks/overlays/useOverlayStack\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport type { OverlayProps } from \"../overlay/overlayProps\";\nimport { getKeyboardFocusableElements } from \"../overlay/overlayUtils\";\nimport { Portal } from \"../portal/portal\";\n\nimport type { OverlayInstance } from \"./overlayInstance\";\n\nexport interface Overlay2Props extends OverlayProps, React.RefAttributes<OverlayInstance> {\n    /**\n     * If you provide a single child element to Overlay2 and attach your own `ref` to the node, you must pass the\n     * same value here (otherwise, Overlay2 won't be able to render CSSTransition correctly).\n     *\n     * Mutually exclusive with the `childRefs` prop. This prop is a shorthand for `childRefs={{ [key: string]: ref }}`.\n     */\n    childRef?: React.RefObject<HTMLElement>;\n\n    /**\n     * If you provide a _multiple child elements_ to Overlay2, you must enumerate and generate a\n     * collection of DOM refs to those elements and provide it here. The object's keys must correspond to the child\n     * React element `key` values.\n     *\n     * Mutually exclusive with the `childRef` prop. If you only provide a single child element, consider using\n     * `childRef` instead.\n     */\n    childRefs?: Record<string, React.RefObject<HTMLElement>>;\n}\n\nexport const OVERLAY2_DEFAULT_PROPS = {\n    autoFocus: true,\n    backdropProps: {},\n    canEscapeKeyClose: true,\n    canOutsideClickClose: true,\n    enforceFocus: true,\n    hasBackdrop: true,\n    isOpen: false,\n    lazy: hasDOMEnvironment(),\n    shouldReturnFocusOnClose: true,\n    transitionDuration: 300,\n    transitionName: Classes.OVERLAY,\n    usePortal: true,\n};\n\n/**\n * Overlay2 component.\n *\n * @see https://blueprintjs.com/docs/#core/components/overlay2\n */\nexport const Overlay2 = React.forwardRef<OverlayInstance, Overlay2Props>((props, forwardedRef) => {\n    const {\n        autoFocus,\n        backdropClassName,\n        backdropProps,\n        canEscapeKeyClose,\n        canOutsideClickClose,\n        childRef,\n        childRefs,\n        children,\n        className,\n        enforceFocus,\n        hasBackdrop,\n        isOpen,\n        lazy,\n        onClose,\n        onClosed,\n        onClosing,\n        onOpened,\n        onOpening,\n        portalClassName,\n        portalContainer,\n        shouldReturnFocusOnClose,\n        transitionDuration,\n        transitionName,\n        usePortal,\n    } = props;\n\n    useOverlay2Validation(props);\n    const { closeOverlay, getLastOpened, getThisOverlayAndDescendants, openOverlay } = useOverlayStack();\n\n    const [isAutoFocusing, setIsAutoFocusing] = React.useState(false);\n    const [hasEverOpened, setHasEverOpened] = React.useState(false);\n    const lastActiveElementBeforeOpened = React.useRef<Element>(null);\n\n    /** Ref for container element, containing all children and the backdrop */\n    const containerElement = React.useRef<HTMLDivElement>(null);\n\n    /** Ref for backdrop element */\n    const backdropElement = React.useRef<HTMLDivElement>(null);\n\n    /* An empty, keyboard-focusable div at the beginning of the Overlay content */\n    const startFocusTrapElement = React.useRef<HTMLDivElement>(null);\n\n    /* An empty, keyboard-focusable div at the end of the Overlay content */\n    const endFocusTrapElement = React.useRef<HTMLDivElement>(null);\n\n    /**\n     * Locally-generated DOM ref for a singleton child element.\n     * This is only used iff the user does not specify the `childRef` or `childRefs` props.\n     */\n    const localChildRef = React.useRef<HTMLElement>(null);\n\n    const bringFocusInsideOverlay = React.useCallback(() => {\n        // always delay focus manipulation to just before repaint to prevent scroll jumping\n        return requestAnimationFrame(() => {\n            // container element may be undefined between component mounting and Portal rendering\n            // activeElement may be undefined in some rare cases in IE\n            const container = getRef(containerElement);\n            const activeElement = getActiveElement(container);\n\n            if (container == null || activeElement == null) {\n                return;\n            }\n\n            // Overlay2 is guaranteed to be mounted here\n            const isFocusOutsideModal = !container.contains(activeElement);\n            if (isFocusOutsideModal) {\n                getRef(startFocusTrapElement)?.focus({ preventScroll: true });\n                setIsAutoFocusing(false);\n            }\n        });\n    }, []);\n\n    /** Unique ID for this overlay in the global stack */\n    const id = useOverlay2ID();\n\n    // N.B. use `null` here and not simply `undefined` because `useImperativeHandle` will set `null` on unmount,\n    // and we need the following code to be resilient to that value.\n    const instance = React.useRef<OverlayInstance>(null);\n\n    /**\n     * When multiple `enforceFocus` Overlays are open, this event handler is only active for the most\n     * recently opened one to avoid Overlays competing with each other for focus.\n     */\n    const handleDocumentFocus = React.useCallback(\n        (e: FocusEvent) => {\n            // get the actual target even in the Shadow DOM\n            // see https://github.com/palantir/blueprint/issues/4220\n            const eventTarget = e.composed ? e.composedPath()[0] : e.target;\n            const container = getRef(containerElement);\n            if (container != null && eventTarget instanceof Node && !container.contains(eventTarget as HTMLElement)) {\n                // prevent default focus behavior (sometimes auto-scrolls the page)\n                e.preventDefault();\n                e.stopImmediatePropagation();\n                bringFocusInsideOverlay();\n            }\n        },\n        [bringFocusInsideOverlay],\n    );\n\n    // N.B. this listener is only kept attached when `isOpen={true}` and `canOutsideClickClose={true}`\n    const handleDocumentMousedown = React.useCallback(\n        (e: MouseEvent) => {\n            // get the actual target even in the Shadow DOM\n            // see https://github.com/palantir/blueprint/issues/4220\n            const eventTarget = (e.composed ? e.composedPath()[0] : e.target) as HTMLElement;\n\n            const thisOverlayAndDescendants = getThisOverlayAndDescendants(id);\n            const isClickInThisOverlayOrDescendant = thisOverlayAndDescendants.some(\n                ({ containerElement: containerRef }) => {\n                    // `elem` is the container of backdrop & content, so clicking directly on that container\n                    // should not count as being \"inside\" the overlay.\n                    const elem = getRef(containerRef);\n                    return elem?.contains(eventTarget) && !elem.isSameNode(eventTarget);\n                },\n            );\n\n            if (!isClickInThisOverlayOrDescendant) {\n                // casting to any because this is a native event\n                onClose?.(e as any);\n            }\n        },\n        [getThisOverlayAndDescendants, id, onClose],\n    );\n\n    // send this instance's imperative handle to the the forwarded ref as well as our local ref\n    const ref = React.useMemo(() => mergeRefs(forwardedRef, instance), [forwardedRef]);\n    React.useImperativeHandle(\n        ref,\n        () => ({\n            bringFocusInsideOverlay,\n            containerElement,\n            handleDocumentFocus,\n            handleDocumentMousedown,\n            id,\n            props: {\n                autoFocus,\n                enforceFocus,\n                hasBackdrop,\n                usePortal,\n            },\n        }),\n        [\n            autoFocus,\n            bringFocusInsideOverlay,\n            enforceFocus,\n            handleDocumentFocus,\n            handleDocumentMousedown,\n            hasBackdrop,\n            id,\n            usePortal,\n        ],\n    );\n\n    const handleContainerKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLElement>) => {\n            if (e.key === \"Escape\" && canEscapeKeyClose) {\n                onClose?.(e);\n                // prevent other overlays from closing\n                e.stopPropagation();\n                // prevent browser-specific escape key behavior (Safari exits fullscreen)\n                e.preventDefault();\n            }\n        },\n        [canEscapeKeyClose, onClose],\n    );\n\n    const overlayWillOpen = React.useCallback(() => {\n        if (instance.current == null) {\n            return;\n        }\n\n        const lastOpenedOverlay = getLastOpened();\n        if (lastOpenedOverlay?.handleDocumentFocus !== undefined) {\n            document.removeEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);\n        }\n        openOverlay(instance.current);\n\n        if (autoFocus) {\n            setIsAutoFocusing(true);\n            bringFocusInsideOverlay();\n        }\n\n        setRef(lastActiveElementBeforeOpened, getActiveElement(getRef(containerElement)));\n    }, [autoFocus, bringFocusInsideOverlay, getLastOpened, openOverlay]);\n\n    const overlayWillClose = React.useCallback(() => {\n        document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */ true);\n        document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n\n        // N.B. `instance.current` may be null at this point if we are cleaning up an open overlay during the unmount phase\n        // (this is common, for example, with context menu's singleton `showContextMenu` / `hideContextMenu` imperative APIs).\n        closeOverlay(id);\n        const lastOpenedOverlay = getLastOpened();\n        if (lastOpenedOverlay !== undefined) {\n            // Only bring focus back to last overlay if it had autoFocus _and_ enforceFocus enabled.\n            // If `autoFocus={false}`, it's likely that the overlay never received focus in the first place,\n            // so it would be surprising for us to send it there. See https://github.com/palantir/blueprint/issues/4921\n            if (lastOpenedOverlay.props.autoFocus && lastOpenedOverlay.props.enforceFocus) {\n                lastOpenedOverlay.bringFocusInsideOverlay?.();\n                if (lastOpenedOverlay.handleDocumentFocus !== undefined) {\n                    document.addEventListener(\"focus\", lastOpenedOverlay.handleDocumentFocus, /* useCapture */ true);\n                }\n            }\n        }\n    }, [closeOverlay, getLastOpened, handleDocumentFocus, handleDocumentMousedown, id]);\n\n    const prevIsOpen = usePrevious(isOpen) ?? false;\n    React.useEffect(() => {\n        if (isOpen) {\n            setHasEverOpened(true);\n        }\n\n        if (!prevIsOpen && isOpen) {\n            // just opened\n            overlayWillOpen();\n        }\n\n        if (prevIsOpen && !isOpen) {\n            // just closed\n            overlayWillClose();\n        }\n    }, [isOpen, overlayWillOpen, overlayWillClose, prevIsOpen]);\n\n    // Important: clean up old document-level event listeners if their memoized values change (this is rare, but\n    // may happen, for example, if a user forgets to use `React.useCallback` in the `props.onClose` value).\n    // Otherwise, we will lose the reference to those values and create a memory leak since we won't be able\n    // to successfully detach them inside overlayWillClose.\n    React.useEffect(() => {\n        if (!isOpen || !(canOutsideClickClose && !hasBackdrop)) {\n            return;\n        }\n\n        document.addEventListener(\"mousedown\", handleDocumentMousedown);\n\n        return () => {\n            document.removeEventListener(\"mousedown\", handleDocumentMousedown);\n        };\n    }, [handleDocumentMousedown, isOpen, canOutsideClickClose, hasBackdrop]);\n    React.useEffect(() => {\n        if (!isOpen || !enforceFocus) {\n            return;\n        }\n\n        // Focus events do not bubble, but setting useCapture allows us to listen in and execute\n        // our handler before all others\n        document.addEventListener(\"focus\", handleDocumentFocus, /* useCapture */ true);\n\n        return () => {\n            document.removeEventListener(\"focus\", handleDocumentFocus, /* useCapture */ true);\n        };\n    }, [handleDocumentFocus, enforceFocus, isOpen]);\n\n    const overlayWillCloseRef = React.useRef(overlayWillClose);\n    overlayWillCloseRef.current = overlayWillClose;\n    React.useEffect(() => {\n        // run cleanup code once on unmount, ensuring we call the most recent overlayWillClose callback\n        // by storing in a ref and keeping up to date\n        return () => {\n            overlayWillCloseRef.current();\n        };\n    }, []);\n\n    const handleTransitionExited = React.useCallback(\n        (node: HTMLElement) => {\n            const lastActiveElement = getRef(lastActiveElementBeforeOpened);\n            if (shouldReturnFocusOnClose && lastActiveElement instanceof HTMLElement) {\n                lastActiveElement.focus();\n            }\n            onClosed?.(node);\n        },\n        [onClosed, shouldReturnFocusOnClose],\n    );\n\n    // N.B. CSSTransition requires this callback to be defined, even if it's unused.\n    const handleTransitionAddEnd = React.useCallback(() => {\n        // no-op\n    }, []);\n\n    /**\n     * Gets the relevant DOM ref for a child element using the `childRef` or `childRefs` props (if possible).\n     * This ref is necessary for `CSSTransition` to work in React 18 without relying on `ReactDOM.findDOMNode`.\n     *\n     * Returns `undefined` if the user did not specify either of those props. In those cases, we use the ref we\n     * have locally generated and expect that the user _did not_ specify their own `ref` on the child element\n     * (it will get clobbered / overriden).\n     *\n     * @see https://reactcommunity.org/react-transition-group/css-transition\n     */\n    const getUserChildRef = React.useCallback(\n        (child: React.ReactNode) => {\n            if (childRef != null) {\n                return childRef;\n            } else if (childRefs != null) {\n                const key = (child as React.ReactElement).key;\n                if (key == null) {\n                    if (!isNodeEnv(\"production\")) {\n                        console.error(OVERLAY_CHILD_REQUIRES_KEY);\n                    }\n                    return undefined;\n                }\n                return childRefs[key];\n            }\n            return undefined;\n        },\n        [childRef, childRefs],\n    );\n\n    const maybeRenderChild = React.useCallback(\n        (child: React.ReactNode | undefined) => {\n            if (child == null || isEmptyString(child)) {\n                return null;\n            }\n\n            // decorate the child with a few injected props\n            const userChildRef = getUserChildRef(child);\n            const childProps = isReactElement(child) ? child.props : {};\n            // if the child is a string, number, or fragment, it will be wrapped in a <span> element\n            const decoratedChild = ensureElement(child, \"span\", {\n                className: classNames(childProps.className, Classes.OVERLAY_CONTENT),\n                // IMPORTANT: only inject our ref if the user didn't specify childRef or childRefs already. Otherwise,\n                // we risk clobbering the user's ref (which we cannot inspect here while cloning/decorating the child).\n                ref: userChildRef === undefined ? localChildRef : undefined,\n                tabIndex: enforceFocus || autoFocus ? 0 : undefined,\n            });\n            const resolvedChildRef = userChildRef ?? localChildRef;\n\n            return (\n                <CSSTransition\n                    addEndListener={handleTransitionAddEnd}\n                    classNames={transitionName}\n                    // HACKHACK: CSSTransition types are slightly incompatible with React types here.\n                    // React prefers `| null` but not `| undefined` for the ref value, while\n                    // CSSTransition _demands_ that `| undefined` be part of the element type.\n                    nodeRef={resolvedChildRef as React.RefObject<HTMLElement | undefined>}\n                    onEntered={getLifecycleCallbackWithChildRef(onOpened, resolvedChildRef)}\n                    onEntering={getLifecycleCallbackWithChildRef(onOpening, resolvedChildRef)}\n                    onExited={getLifecycleCallbackWithChildRef(handleTransitionExited, resolvedChildRef)}\n                    onExiting={getLifecycleCallbackWithChildRef(onClosing, resolvedChildRef)}\n                    timeout={transitionDuration}\n                >\n                    {decoratedChild}\n                </CSSTransition>\n            );\n        },\n        [\n            autoFocus,\n            enforceFocus,\n            getUserChildRef,\n            handleTransitionAddEnd,\n            handleTransitionExited,\n            onClosing,\n            onOpened,\n            onOpening,\n            transitionDuration,\n            transitionName,\n        ],\n    );\n\n    const handleBackdropMouseDown = React.useCallback(\n        (e: React.MouseEvent<HTMLDivElement>) => {\n            if (canOutsideClickClose) {\n                onClose?.(e);\n            }\n            if (enforceFocus) {\n                bringFocusInsideOverlay();\n            }\n            backdropProps?.onMouseDown?.(e);\n        },\n        [backdropProps, bringFocusInsideOverlay, canOutsideClickClose, enforceFocus, onClose],\n    );\n\n    const renderDummyElement = React.useCallback(\n        (key: string, dummyElementProps: HTMLDivProps & { ref?: React.Ref<HTMLDivElement> }) => (\n            <CSSTransition\n                addEndListener={handleTransitionAddEnd}\n                classNames={transitionName}\n                key={key}\n                nodeRef={dummyElementProps.ref}\n                timeout={transitionDuration}\n                unmountOnExit={true}\n            >\n                <div tabIndex={0} {...dummyElementProps} />\n            </CSSTransition>\n        ),\n        [handleTransitionAddEnd, transitionDuration, transitionName],\n    );\n\n    /**\n     * Ensures repeatedly pressing shift+tab keeps focus inside the Overlay. Moves focus to\n     * the `endFocusTrapElement` or the first keyboard-focusable element in the Overlay (excluding\n     * the `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    const handleStartFocusTrapElementFocus = React.useCallback(\n        (e: React.FocusEvent<HTMLDivElement>) => {\n            if (!enforceFocus || isAutoFocusing) {\n                return;\n            }\n            // e.relatedTarget will not be defined if this was a programmatic focus event, as is the\n            // case when we call this.bringFocusInsideOverlay() after a user clicked on the backdrop.\n            // Otherwise, we're handling a user interaction, and we should wrap around to the last\n            // element in this transition group.\n            const container = getRef(containerElement);\n            const endFocusTrap = getRef(endFocusTrapElement);\n            if (\n                e.relatedTarget != null &&\n                container?.contains(e.relatedTarget as Element) &&\n                e.relatedTarget !== endFocusTrap\n            ) {\n                endFocusTrap?.focus({ preventScroll: true });\n            }\n        },\n        [enforceFocus, isAutoFocusing],\n    );\n\n    /**\n     * Wrap around to the end of the dialog if `enforceFocus` is enabled.\n     */\n    const handleStartFocusTrapElementKeyDown = React.useCallback(\n        (e: React.KeyboardEvent<HTMLDivElement>) => {\n            if (!enforceFocus) {\n                return;\n            }\n            if (e.shiftKey && e.key === \"Tab\") {\n                const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n                if (lastFocusableElement != null) {\n                    lastFocusableElement.focus();\n                } else {\n                    getRef(endFocusTrapElement)?.focus({ preventScroll: true });\n                }\n            }\n        },\n        [enforceFocus],\n    );\n\n    /**\n     * Ensures repeatedly pressing tab keeps focus inside the Overlay. Moves focus to the\n     * `startFocusTrapElement` or the last keyboard-focusable element in the Overlay (excluding the\n     * `startFocusTrapElement`), depending on whether the element losing focus is inside the\n     * Overlay.\n     */\n    const handleEndFocusTrapElementFocus = React.useCallback(\n        (e: React.FocusEvent<HTMLDivElement>) => {\n            // No need for this.props.enforceFocus check here because this element is only rendered\n            // when that prop is true.\n            // During user interactions, e.relatedTarget will be defined, and we should wrap around to the\n            // \"start focus trap\" element.\n            // Otherwise, we're handling a programmatic focus event, which can only happen after a user\n            // presses shift+tab from the first focusable element in the overlay.\n            const startFocusTrap = getRef(startFocusTrapElement);\n            if (\n                e.relatedTarget != null &&\n                getRef(containerElement)?.contains(e.relatedTarget as Element) &&\n                e.relatedTarget !== startFocusTrap\n            ) {\n                const firstFocusableElement = getKeyboardFocusableElements(containerElement).shift();\n                // ensure we don't re-focus an already active element by comparing against e.relatedTarget\n                if (!isAutoFocusing && firstFocusableElement != null && firstFocusableElement !== e.relatedTarget) {\n                    firstFocusableElement.focus();\n                } else {\n                    startFocusTrap?.focus({ preventScroll: true });\n                }\n            } else {\n                const lastFocusableElement = getKeyboardFocusableElements(containerElement).pop();\n                if (lastFocusableElement != null) {\n                    lastFocusableElement.focus();\n                } else {\n                    // Keeps focus within Overlay even if there are no keyboard-focusable children\n                    startFocusTrap?.focus({ preventScroll: true });\n                }\n            }\n        },\n        [isAutoFocusing],\n    );\n\n    const maybeBackdrop = React.useMemo(\n        () =>\n            hasBackdrop && isOpen ? (\n                <CSSTransition\n                    classNames={transitionName}\n                    key=\"__backdrop\"\n                    nodeRef={backdropElement}\n                    timeout={transitionDuration}\n                    addEndListener={handleTransitionAddEnd}\n                >\n                    <div\n                        {...backdropProps}\n                        className={classNames(Classes.OVERLAY_BACKDROP, backdropClassName, backdropProps?.className)}\n                        onMouseDown={handleBackdropMouseDown}\n                        ref={backdropElement}\n                    />\n                </CSSTransition>\n            ) : null,\n        [\n            backdropClassName,\n            backdropProps,\n            handleBackdropMouseDown,\n            handleTransitionAddEnd,\n            hasBackdrop,\n            isOpen,\n            transitionDuration,\n            transitionName,\n        ],\n    );\n\n    // no reason to render anything at all if we're being truly lazy\n    if (lazy && !hasEverOpened) {\n        return null;\n    }\n\n    // TransitionGroup types require single array of children; does not support nested arrays.\n    // So we must collapse backdrop and children into one array, and every item must be wrapped in a\n    // Transition element (no ReactText allowed).\n    const childrenWithTransitions = isOpen ? React.Children.map(children, maybeRenderChild) ?? [] : [];\n\n    // const maybeBackdrop = maybeRenderBackdrop();\n    if (maybeBackdrop !== null) {\n        childrenWithTransitions.unshift(maybeBackdrop);\n    }\n    if (isOpen && (autoFocus || enforceFocus) && childrenWithTransitions.length > 0) {\n        childrenWithTransitions.unshift(\n            renderDummyElement(\"__start\", {\n                className: Classes.OVERLAY_START_FOCUS_TRAP,\n                onFocus: handleStartFocusTrapElementFocus,\n                onKeyDown: handleStartFocusTrapElementKeyDown,\n                ref: startFocusTrapElement,\n            }),\n        );\n        if (enforceFocus) {\n            childrenWithTransitions.push(\n                renderDummyElement(\"__end\", {\n                    className: Classes.OVERLAY_END_FOCUS_TRAP,\n                    onFocus: handleEndFocusTrapElementFocus,\n                    ref: endFocusTrapElement,\n                }),\n            );\n        }\n    }\n\n    const transitionGroup = (\n        <div\n            aria-live=\"polite\"\n            className={classNames(\n                Classes.OVERLAY,\n                {\n                    [Classes.OVERLAY_OPEN]: isOpen,\n                    [Classes.OVERLAY_INLINE]: !usePortal,\n                },\n                className,\n            )}\n            onKeyDown={handleContainerKeyDown}\n            ref={containerElement}\n        >\n            <TransitionGroup appear={true} component={null}>\n                {childrenWithTransitions}\n            </TransitionGroup>\n        </div>\n    );\n\n    if (usePortal) {\n        return (\n            <Portal className={portalClassName} container={portalContainer}>\n                {transitionGroup}\n            </Portal>\n        );\n    } else {\n        return transitionGroup;\n    }\n});\n// eslint-disable-next-line @typescript-eslint/no-deprecated\nOverlay2.defaultProps = OVERLAY2_DEFAULT_PROPS;\nOverlay2.displayName = `${DISPLAYNAME_PREFIX}.Overlay2`;\n\nfunction useOverlay2Validation({ childRef, childRefs, children }: Overlay2Props) {\n    const numChildren = React.Children.count(children);\n    React.useEffect(() => {\n        if (isNodeEnv(\"production\")) {\n            return;\n        }\n\n        if (childRef != null && childRefs != null) {\n            console.error(OVERLAY_CHILD_REF_AND_REFS_MUTEX);\n        }\n\n        if (numChildren > 1 && childRefs == null) {\n            console.error(OVERLAY_WITH_MULTIPLE_CHILDREN_REQUIRES_CHILD_REFS);\n        }\n    }, [childRef, childRefs, numChildren]);\n}\n\n/**\n * Generates a unique ID for a given Overlay which persists across the component's lifecycle.\n */\nfunction useOverlay2ID(): string {\n    // TODO: migrate to React.useId() in React 18\n    const id = useUID();\n    return `${Overlay2.displayName}-${id}`;\n}\n\n// N.B. the `onExiting` callback is not provided with the `node` argument as suggested in CSSTransition types since\n// we are using the `nodeRef` prop, so we must inject it dynamically.\nfunction getLifecycleCallbackWithChildRef(\n    callback: ((node: HTMLElement) => void) | undefined,\n    childRef: React.RefObject<HTMLElement> | undefined,\n) {\n    return () => {\n        if (childRef?.current != null) {\n            callback?.(childRef.current);\n        }\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}