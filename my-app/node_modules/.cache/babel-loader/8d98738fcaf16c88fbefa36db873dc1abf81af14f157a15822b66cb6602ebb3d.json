{"ast":null,"code":"/* !\n * (c) Copyright 2023 Palantir Technologies Inc. All rights reserved.\n */\nimport * as React from \"react\";\n/**\n * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n */\nexport var ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY = 10;\n/**\n * A hook to workaround the following [React bug](https://github.com/facebook/react/issues/3926).\n * This bug is reproduced when an input receives CompositionEvents\n * (for example, through IME composition) and has its value prop updated asychronously.\n * This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n */\nexport function useAsyncControllableValue(props) {\n  var onCompositionStart = props.onCompositionStart,\n    onCompositionEnd = props.onCompositionEnd,\n    propValue = props.value,\n    onChange = props.onChange;\n  // The source of truth for the input value. This is not updated during IME composition.\n  // It may be updated by a parent component.\n  var _a = React.useState(propValue),\n    value = _a[0],\n    setValue = _a[1];\n  // The latest input value, which updates during IME composition.\n  var _b = React.useState(propValue),\n    nextValue = _b[0],\n    setNextValue = _b[1];\n  // Whether we are in the middle of a composition event.\n  var _c = React.useState(false),\n    isComposing = _c[0],\n    setIsComposing = _c[1];\n  // Whether there is a pending update we are expecting from a parent component.\n  var _d = React.useState(false),\n    hasPendingUpdate = _d[0],\n    setHasPendingUpdate = _d[1];\n  var cancelPendingCompositionEnd = React.useRef();\n  var handleCompositionStart = React.useCallback(function (event) {\n    var _a;\n    (_a = cancelPendingCompositionEnd.current) === null || _a === void 0 ? void 0 : _a.call(cancelPendingCompositionEnd);\n    setIsComposing(true);\n    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(event);\n  }, [onCompositionStart]);\n  // creates a timeout which will set `isComposing` to false after a delay\n  // returns a function which will cancel the timeout if called before it fires\n  var createOnCancelPendingCompositionEnd = React.useCallback(function () {\n    var timeoutId = window.setTimeout(function () {\n      return setIsComposing(false);\n    }, ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY);\n    return function () {\n      return window.clearTimeout(timeoutId);\n    };\n  }, []);\n  var handleCompositionEnd = React.useCallback(function (event) {\n    // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n    // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n    // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n    // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n    // passed without a new composition event starting.\n    cancelPendingCompositionEnd.current = createOnCancelPendingCompositionEnd();\n    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(event);\n  }, [createOnCancelPendingCompositionEnd, onCompositionEnd]);\n  var handleChange = React.useCallback(function (event) {\n    var targetValue = event.target.value;\n    setNextValue(targetValue);\n    onChange === null || onChange === void 0 ? void 0 : onChange(event);\n  }, [onChange]);\n  // don't derive anything from props if:\n  // - in uncontrolled mode, OR\n  // - currently composing, since we'll do that after composition ends\n  var shouldDeriveFromProps = !(isComposing || propValue === undefined);\n  if (shouldDeriveFromProps) {\n    var userTriggeredUpdate = nextValue !== value;\n    if (userTriggeredUpdate && propValue === nextValue) {\n      // parent has processed and accepted our update\n      setValue(propValue);\n      setHasPendingUpdate(false);\n    } else if (userTriggeredUpdate && propValue === value) {\n      // we have sent the update to our parent, but it has not been processed yet. just wait.\n      // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n      // causing the cursor to jump once the new value is accepted\n      if (!hasPendingUpdate) {\n        // make sure to setState only when necessary to avoid infinite loops\n        setHasPendingUpdate(true);\n      }\n    } else if (userTriggeredUpdate && propValue !== value) {\n      // accept controlled update overriding user action\n      setValue(propValue);\n      setNextValue(propValue);\n      setHasPendingUpdate(false);\n    } else if (!userTriggeredUpdate) {\n      // accept controlled update, could be confirming or denying user action\n      if (value !== propValue || hasPendingUpdate) {\n        // make sure to setState only when necessary to avoid infinite loops\n        setValue(propValue);\n        setNextValue(propValue);\n        setHasPendingUpdate(false);\n      }\n    }\n  }\n  return {\n    onChange: handleChange,\n    onCompositionEnd: handleCompositionEnd,\n    onCompositionStart: handleCompositionStart,\n    // render the pending value even if it is not confirmed by a parent's async controlled update\n    // so that the cursor does not jump to the end of input as reported in\n    // https://github.com/palantir/blueprint/issues/4298\n    value: isComposing || hasPendingUpdate ? nextValue : value\n  };\n}","map":{"version":3,"names":["React","ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY","useAsyncControllableValue","props","onCompositionStart","onCompositionEnd","propValue","value","onChange","_a","useState","setValue","_b","nextValue","setNextValue","_c","isComposing","setIsComposing","_d","hasPendingUpdate","setHasPendingUpdate","cancelPendingCompositionEnd","useRef","handleCompositionStart","useCallback","event","current","call","createOnCancelPendingCompositionEnd","timeoutId","window","setTimeout","clearTimeout","handleCompositionEnd","handleChange","targetValue","target","shouldDeriveFromProps","undefined","userTriggeredUpdate"],"sources":["C:\\Users\\deepa\\Deepak\\Working-File\\React-Project\\new-working-file\\React-Project\\my-app\\node_modules\\@blueprintjs\\core\\src\\hooks\\useAsyncControllableValue.ts"],"sourcesContent":["/* !\n * (c) Copyright 2023 Palantir Technologies Inc. All rights reserved.\n */\n\nimport * as React from \"react\";\n\ninterface UseAsyncControllableValueProps<E extends HTMLInputElement | HTMLTextAreaElement> {\n    value?: React.InputHTMLAttributes<E>[\"value\"];\n    onChange?: React.ChangeEventHandler<E>;\n    onCompositionStart?: React.CompositionEventHandler<E>;\n    onCompositionEnd?: React.CompositionEventHandler<E>;\n}\n\n/**\n * The amount of time (in milliseconds) which the input will wait after a compositionEnd event before\n * unlocking its state value for external updates via props. See `handleCompositionEnd` for more details.\n */\nexport const ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY = 10;\n\n/**\n * A hook to workaround the following [React bug](https://github.com/facebook/react/issues/3926).\n * This bug is reproduced when an input receives CompositionEvents\n * (for example, through IME composition) and has its value prop updated asychronously.\n * This might happen if a component chooses to do async validation of a value\n * returned by the input's `onChange` callback.\n */\nexport function useAsyncControllableValue<E extends HTMLInputElement | HTMLTextAreaElement>(\n    props: UseAsyncControllableValueProps<E>,\n) {\n    const { onCompositionStart, onCompositionEnd, value: propValue, onChange } = props;\n\n    // The source of truth for the input value. This is not updated during IME composition.\n    // It may be updated by a parent component.\n    const [value, setValue] = React.useState(propValue);\n\n    // The latest input value, which updates during IME composition.\n    const [nextValue, setNextValue] = React.useState(propValue);\n\n    // Whether we are in the middle of a composition event.\n    const [isComposing, setIsComposing] = React.useState(false);\n\n    // Whether there is a pending update we are expecting from a parent component.\n    const [hasPendingUpdate, setHasPendingUpdate] = React.useState(false);\n\n    const cancelPendingCompositionEnd = React.useRef<() => void>();\n\n    const handleCompositionStart: React.CompositionEventHandler<E> = React.useCallback(\n        event => {\n            cancelPendingCompositionEnd.current?.();\n            setIsComposing(true);\n            onCompositionStart?.(event);\n        },\n        [onCompositionStart],\n    );\n\n    // creates a timeout which will set `isComposing` to false after a delay\n    // returns a function which will cancel the timeout if called before it fires\n    const createOnCancelPendingCompositionEnd = React.useCallback(() => {\n        const timeoutId = window.setTimeout(\n            () => setIsComposing(false),\n            ASYNC_CONTROLLABLE_VALUE_COMPOSITION_END_DELAY,\n        );\n        return () => window.clearTimeout(timeoutId);\n    }, []);\n\n    const handleCompositionEnd: React.CompositionEventHandler<E> = React.useCallback(\n        event => {\n            // In some non-latin languages, a keystroke can end a composition event and immediately afterwards start another.\n            // This can lead to unexpected characters showing up in the text input. In order to circumvent this problem, we\n            // use a timeout which creates a delay which merges the two composition events, creating a more natural and predictable UX.\n            // `this.state.nextValue` will become \"locked\" (it cannot be overwritten by the `value` prop) until a delay (10ms) has\n            // passed without a new composition event starting.\n            cancelPendingCompositionEnd.current = createOnCancelPendingCompositionEnd();\n            onCompositionEnd?.(event);\n        },\n        [createOnCancelPendingCompositionEnd, onCompositionEnd],\n    );\n\n    const handleChange: React.ChangeEventHandler<E> = React.useCallback(\n        event => {\n            const { value: targetValue } = event.target;\n            setNextValue(targetValue);\n            onChange?.(event);\n        },\n        [onChange],\n    );\n\n    // don't derive anything from props if:\n    // - in uncontrolled mode, OR\n    // - currently composing, since we'll do that after composition ends\n    const shouldDeriveFromProps = !(isComposing || propValue === undefined);\n\n    if (shouldDeriveFromProps) {\n        const userTriggeredUpdate = nextValue !== value;\n\n        if (userTriggeredUpdate && propValue === nextValue) {\n            // parent has processed and accepted our update\n            setValue(propValue);\n            setHasPendingUpdate(false);\n        } else if (userTriggeredUpdate && propValue === value) {\n            // we have sent the update to our parent, but it has not been processed yet. just wait.\n            // DO NOT set nextValue here, since that will temporarily render a potentially stale controlled value,\n            // causing the cursor to jump once the new value is accepted\n            if (!hasPendingUpdate) {\n                // make sure to setState only when necessary to avoid infinite loops\n                setHasPendingUpdate(true);\n            }\n        } else if (userTriggeredUpdate && propValue !== value) {\n            // accept controlled update overriding user action\n            setValue(propValue);\n            setNextValue(propValue);\n            setHasPendingUpdate(false);\n        } else if (!userTriggeredUpdate) {\n            // accept controlled update, could be confirming or denying user action\n            if (value !== propValue || hasPendingUpdate) {\n                // make sure to setState only when necessary to avoid infinite loops\n                setValue(propValue);\n                setNextValue(propValue);\n                setHasPendingUpdate(false);\n            }\n        }\n    }\n\n    return {\n        onChange: handleChange,\n        onCompositionEnd: handleCompositionEnd,\n        onCompositionStart: handleCompositionStart,\n        // render the pending value even if it is not confirmed by a parent's async controlled update\n        // so that the cursor does not jump to the end of input as reported in\n        // https://github.com/palantir/blueprint/issues/4298\n        value: isComposing || hasPendingUpdate ? nextValue : value,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}