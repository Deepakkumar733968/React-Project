{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { formatPercentage } from \"./sliderUtils\";\n// props that require number values, for validation\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nvar Handle = /** @class */function (_super) {\n  __extends(Handle, _super);\n  function Handle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.state = {\n      isMoving: false\n    };\n    _this.handleElement = null;\n    _this.refHandlers = {\n      handle: function (el) {\n        return _this.handleElement = el;\n      }\n    };\n    _this.beginHandleMovement = function (event) {\n      document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", _this.endHandleMovement);\n      _this.setState({\n        isMoving: true\n      });\n      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n    };\n    _this.beginHandleTouchMovement = function (event) {\n      document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n      _this.setState({\n        isMoving: true\n      });\n      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n    };\n    _this.getStyleProperties = function () {\n      if (_this.handleElement == null) {\n        return {};\n      }\n      // The handle midpoint of RangeSlider is actually shifted by a margin to\n      // be on the edge of the visible handle element. Because the midpoint\n      // calculation does not take this margin into account, we instead\n      // measure the long side (which is equal to the short side plus the\n      // margin).\n      var _a = _this.props,\n        _b = _a.min,\n        min = _b === void 0 ? 0 : _b,\n        tickSizeRatio = _a.tickSizeRatio,\n        value = _a.value,\n        vertical = _a.vertical;\n      var handleMidpoint = _this.getHandleMidpointAndOffset(_this.handleElement, true).handleMidpoint;\n      var offsetRatio = (value - min) * tickSizeRatio;\n      var offsetCalc = \"calc(\".concat(formatPercentage(offsetRatio), \" - \").concat(handleMidpoint, \"px)\");\n      return vertical ? {\n        bottom: offsetCalc\n      } : {\n        left: offsetCalc\n      };\n    };\n    _this.endHandleMovement = function (event) {\n      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n    };\n    _this.endHandleTouchMovement = function (event) {\n      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n    };\n    _this.handleMoveEndedAt = function (clientPixel) {\n      var _a, _b;\n      _this.removeDocumentEventListeners();\n      _this.setState({\n        isMoving: false\n      });\n      // always invoke onRelease; changeValue may call onChange if value is different\n      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n      (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, finalValue);\n    };\n    _this.handleHandleMovement = function (event) {\n      _this.handleMovedTo(_this.mouseEventClientOffset(event));\n    };\n    _this.handleHandleTouchMovement = function (event) {\n      _this.handleMovedTo(_this.touchEventClientOffset(event));\n    };\n    _this.handleMovedTo = function (clientPixel) {\n      if (_this.state.isMoving && !_this.props.disabled) {\n        _this.changeValue(_this.clientToValue(clientPixel));\n      }\n    };\n    _this.handleKeyDown = function (event) {\n      var _a = _this.props,\n        stepSize = _a.stepSize,\n        value = _a.value;\n      var direction = Utils.getArrowKeyDirection(event, [\"ArrowLeft\", \"ArrowDown\"], [\"ArrowRight\", \"ArrowUp\"]);\n      if (direction !== undefined) {\n        _this.changeValue(value + stepSize * direction);\n        // this key event has been handled! prevent browser scroll on up/down\n        event.preventDefault();\n      }\n    };\n    _this.handleKeyUp = function (event) {\n      var _a, _b;\n      if (Utils.isArrowKey(event)) {\n        (_b = (_a = _this.props).onRelease) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.value);\n      }\n    };\n    return _this;\n  }\n  Handle.prototype.componentDidMount = function () {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  };\n  Handle.prototype.render = function () {\n    var _a;\n    var _b = this.props,\n      className = _b.className,\n      disabled = _b.disabled,\n      label = _b.label,\n      min = _b.min,\n      max = _b.max,\n      value = _b.value,\n      vertical = _b.vertical,\n      htmlProps = _b.htmlProps;\n    var isMoving = this.state.isMoving;\n    return React.createElement(\"span\", __assign({\n      role: \"slider\",\n      tabIndex: 0\n    }, htmlProps, {\n      className: classNames(Classes.SLIDER_HANDLE, (_a = {}, _a[Classes.ACTIVE] = isMoving, _a), className),\n      onKeyDown: disabled ? undefined : this.handleKeyDown,\n      onKeyUp: disabled ? undefined : this.handleKeyUp,\n      onMouseDown: disabled ? undefined : this.beginHandleMovement,\n      onTouchStart: disabled ? undefined : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: this.getStyleProperties(),\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-disabled\": disabled,\n      \"aria-orientation\": vertical ? \"vertical\" : \"horizontal\"\n    }), label == null ? null : React.createElement(\"span\", {\n      className: Classes.SLIDER_LABEL\n    }, label));\n  };\n  Handle.prototype.componentWillUnmount = function () {\n    this.removeDocumentEventListeners();\n  };\n  /** Convert client pixel to value between min and max. */\n  Handle.prototype.clientToValue = function (clientPixel) {\n    var _a = this.props,\n      stepSize = _a.stepSize,\n      tickSize = _a.tickSize,\n      value = _a.value,\n      vertical = _a.vertical;\n    if (this.handleElement == null) {\n      return value;\n    }\n    // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    var pixelDelta = clientPixelNormalized - handleCenterPixel;\n    if (isNaN(pixelDelta)) {\n      return value;\n    }\n    // convert pixels to range value in increments of `stepSize`\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  };\n  Handle.prototype.mouseEventClientOffset = function (event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  };\n  Handle.prototype.touchEventClientOffset = function (event) {\n    var touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  };\n  Handle.prototype.validateProps = function (props) {\n    for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n      var prop = NUMBER_PROPS_1[_i];\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(\"[Blueprint] <Handle> requires number value for \".concat(prop, \" prop\"));\n      }\n    }\n  };\n  /** Clamp value and invoke callback if it differs from current value */\n  Handle.prototype.changeValue = function (newValue, callback) {\n    if (callback === void 0) {\n      callback = this.props.onChange;\n    }\n    newValue = this.clamp(newValue);\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      callback === null || callback === void 0 ? void 0 : callback(newValue);\n    }\n    return newValue;\n  };\n  /** Clamp value between min and max props */\n  Handle.prototype.clamp = function (value) {\n    return Utils.clamp(value, this.props.min, this.props.max);\n  };\n  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n    var _a = this.getHandleMidpointAndOffset(handleElement),\n      handleMidpoint = _a.handleMidpoint,\n      handleOffset = _a.handleOffset;\n    return handleOffset + handleMidpoint;\n  };\n  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n    if (useOppositeDimension === void 0) {\n      useOppositeDimension = false;\n    }\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n    var vertical = this.props.vertical;\n    // N.B. element.clientHeight does not include border size.\n    // Also, element.getBoundingClientRect() is useful to get the top & left position on the page, but\n    // it fails to accurately measure element width & height inside absolutely-positioned and CSS-transformed\n    // containers like Popovers, so we use element.offsetWidth & offsetHeight instead (see https://github.com/palantir/blueprint/issues/4417).\n    var handleRect = handleElement.getBoundingClientRect();\n    handleRect.width = handleElement.offsetWidth;\n    handleRect.height = handleElement.offsetHeight;\n    var sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\";\n    // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset: handleOffset\n    };\n  };\n  Handle.prototype.removeDocumentEventListeners = function () {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  };\n  Handle.displayName = \"\".concat(DISPLAYNAME_PREFIX, \".SliderHandle\");\n  return Handle;\n}(AbstractPureComponent);\nexport { Handle };","map":{"version":3,"names":["classNames","React","AbstractPureComponent","Classes","Utils","DISPLAYNAME_PREFIX","formatPercentage","NUMBER_PROPS","Handle","_super","__extends","_this","state","isMoving","handleElement","refHandlers","handle","el","beginHandleMovement","event","document","addEventListener","handleHandleMovement","endHandleMovement","setState","changeValue","clientToValue","mouseEventClientOffset","beginHandleTouchMovement","handleHandleTouchMovement","endHandleTouchMovement","touchEventClientOffset","getStyleProperties","_a","props","_b","min","tickSizeRatio","value","vertical","handleMidpoint","getHandleMidpointAndOffset","offsetRatio","offsetCalc","concat","bottom","left","handleMoveEndedAt","clientPixel","removeDocumentEventListeners","finalValue","onRelease","call","handleMovedTo","disabled","handleKeyDown","stepSize","direction","getArrowKeyDirection","undefined","preventDefault","handleKeyUp","isArrowKey","prototype","componentDidMount","forceUpdate","render","className","label","max","htmlProps","createElement","__assign","role","tabIndex","SLIDER_HANDLE","ACTIVE","onKeyDown","onKeyUp","onMouseDown","onTouchStart","ref","style","SLIDER_LABEL","componentWillUnmount","tickSize","clientPixelNormalized","window","innerHeight","handleCenterPixel","getHandleElementCenterPixel","pixelDelta","isNaN","Math","round","clientY","clientX","touch","changedTouches","validateProps","_i","NUMBER_PROPS_1","length","prop","Error","newValue","callback","onChange","clamp","handleOffset","useOppositeDimension","handleRect","getBoundingClientRect","width","offsetWidth","height","offsetHeight","sizeKey","top","removeEventListener","displayName"],"sources":["C:\\Users\\deepa\\Deepak\\Working-File\\React-Project\\new-working-file\\React-Project\\my-app\\node_modules\\@blueprintjs\\core\\src\\components\\slider\\handle.tsx"],"sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport classNames from \"classnames\";\nimport * as React from \"react\";\n\nimport { AbstractPureComponent, Classes, Utils } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\n\nimport type { HandleProps } from \"./handleProps\";\nimport { formatPercentage } from \"./sliderUtils\";\n\n/**\n * Props for the internal <Handle> component needs some additional info from the parent Slider.\n */\nexport interface InternalHandleProps extends HandleProps {\n    disabled?: boolean;\n    label: React.JSX.Element | string | undefined;\n    max: number;\n    min: number;\n    stepSize: number;\n    tickSize: number;\n    tickSizeRatio: number;\n    vertical: boolean;\n}\n\nexport interface HandleState {\n    /** whether slider handle is currently being dragged */\n    isMoving?: boolean;\n}\n\n// props that require number values, for validation\nconst NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"] satisfies Array<keyof InternalHandleProps>;\n\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\nexport class Handle extends AbstractPureComponent<InternalHandleProps, HandleState> {\n    public static displayName = `${DISPLAYNAME_PREFIX}.SliderHandle`;\n\n    public state = {\n        isMoving: false,\n    };\n\n    private handleElement: HTMLElement | null = null;\n\n    private refHandlers = {\n        handle: (el: HTMLSpanElement) => (this.handleElement = el),\n    };\n\n    public componentDidMount() {\n        // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n        // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n        this.forceUpdate();\n    }\n\n    public render() {\n        const { className, disabled, label, min, max, value, vertical, htmlProps } = this.props;\n        const { isMoving } = this.state;\n\n        return (\n            <span\n                role=\"slider\"\n                tabIndex={0}\n                {...htmlProps}\n                className={classNames(Classes.SLIDER_HANDLE, { [Classes.ACTIVE]: isMoving }, className)}\n                onKeyDown={disabled ? undefined : this.handleKeyDown}\n                onKeyUp={disabled ? undefined : this.handleKeyUp}\n                onMouseDown={disabled ? undefined : this.beginHandleMovement}\n                onTouchStart={disabled ? undefined : this.beginHandleTouchMovement}\n                ref={this.refHandlers.handle}\n                style={this.getStyleProperties()}\n                aria-valuemin={min}\n                aria-valuemax={max}\n                aria-valuenow={value}\n                aria-disabled={disabled}\n                aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n            >\n                {label == null ? null : <span className={Classes.SLIDER_LABEL}>{label}</span>}\n            </span>\n        );\n    }\n\n    public componentWillUnmount() {\n        this.removeDocumentEventListeners();\n    }\n\n    /** Convert client pixel to value between min and max. */\n    public clientToValue(clientPixel: number) {\n        const { stepSize, tickSize, value, vertical } = this.props;\n        if (this.handleElement == null) {\n            return value;\n        }\n\n        // #1769: this logic doesn't work perfectly when the tick size is\n        // smaller than the handle size; it may be off by a tick or two.\n        const clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n        const handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n        const pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n        if (isNaN(pixelDelta)) {\n            return value;\n        }\n        // convert pixels to range value in increments of `stepSize`\n        return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n    }\n\n    public mouseEventClientOffset(event: MouseEvent | React.MouseEvent<HTMLElement>) {\n        return this.props.vertical ? event.clientY : event.clientX;\n    }\n\n    public touchEventClientOffset(event: TouchEvent | React.TouchEvent<HTMLElement>) {\n        const touch = event.changedTouches[0];\n        return this.props.vertical ? touch.clientY : touch.clientX;\n    }\n\n    public beginHandleMovement = (event: MouseEvent | React.MouseEvent<HTMLElement>) => {\n        document.addEventListener(\"mousemove\", this.handleHandleMovement);\n        document.addEventListener(\"mouseup\", this.endHandleMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.mouseEventClientOffset(event)));\n    };\n\n    public beginHandleTouchMovement = (event: TouchEvent | React.TouchEvent<HTMLElement>) => {\n        document.addEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.addEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.addEventListener(\"touchcancel\", this.endHandleTouchMovement);\n        this.setState({ isMoving: true });\n        this.changeValue(this.clientToValue(this.touchEventClientOffset(event)));\n    };\n\n    protected validateProps(props: InternalHandleProps) {\n        for (const prop of NUMBER_PROPS) {\n            if (typeof (props as any)[prop] !== \"number\") {\n                throw new Error(`[Blueprint] <Handle> requires number value for ${prop} prop`);\n            }\n        }\n    }\n\n    private getStyleProperties = (): React.CSSProperties => {\n        if (this.handleElement == null) {\n            return {};\n        }\n\n        // The handle midpoint of RangeSlider is actually shifted by a margin to\n        // be on the edge of the visible handle element. Because the midpoint\n        // calculation does not take this margin into account, we instead\n        // measure the long side (which is equal to the short side plus the\n        // margin).\n\n        const { min = 0, tickSizeRatio, value, vertical } = this.props;\n        const { handleMidpoint } = this.getHandleMidpointAndOffset(this.handleElement, true);\n        const offsetRatio = (value - min) * tickSizeRatio;\n        const offsetCalc = `calc(${formatPercentage(offsetRatio)} - ${handleMidpoint}px)`;\n        return vertical ? { bottom: offsetCalc } : { left: offsetCalc };\n    };\n\n    private endHandleMovement = (event: MouseEvent) => {\n        this.handleMoveEndedAt(this.mouseEventClientOffset(event));\n    };\n\n    private endHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMoveEndedAt(this.touchEventClientOffset(event));\n    };\n\n    private handleMoveEndedAt = (clientPixel: number) => {\n        this.removeDocumentEventListeners();\n        this.setState({ isMoving: false });\n        // always invoke onRelease; changeValue may call onChange if value is different\n        const finalValue = this.changeValue(this.clientToValue(clientPixel));\n        this.props.onRelease?.(finalValue);\n    };\n\n    private handleHandleMovement = (event: MouseEvent) => {\n        this.handleMovedTo(this.mouseEventClientOffset(event));\n    };\n\n    private handleHandleTouchMovement = (event: TouchEvent) => {\n        this.handleMovedTo(this.touchEventClientOffset(event));\n    };\n\n    private handleMovedTo = (clientPixel: number) => {\n        if (this.state.isMoving && !this.props.disabled) {\n            this.changeValue(this.clientToValue(clientPixel));\n        }\n    };\n\n    private handleKeyDown = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        const { stepSize, value } = this.props;\n        const direction = Utils.getArrowKeyDirection(event, [\"ArrowLeft\", \"ArrowDown\"], [\"ArrowRight\", \"ArrowUp\"]);\n        if (direction !== undefined) {\n            this.changeValue(value + stepSize * direction);\n            // this key event has been handled! prevent browser scroll on up/down\n            event.preventDefault();\n        }\n    };\n\n    private handleKeyUp = (event: React.KeyboardEvent<HTMLSpanElement>) => {\n        if (Utils.isArrowKey(event)) {\n            this.props.onRelease?.(this.props.value);\n        }\n    };\n\n    /** Clamp value and invoke callback if it differs from current value */\n    private changeValue(newValue: number, callback = this.props.onChange) {\n        newValue = this.clamp(newValue);\n        if (!isNaN(newValue) && this.props.value !== newValue) {\n            callback?.(newValue);\n        }\n        return newValue;\n    }\n\n    /** Clamp value between min and max props */\n    private clamp(value: number) {\n        return Utils.clamp(value, this.props.min, this.props.max);\n    }\n\n    private getHandleElementCenterPixel(handleElement: HTMLElement) {\n        const { handleMidpoint, handleOffset } = this.getHandleMidpointAndOffset(handleElement);\n        return handleOffset + handleMidpoint;\n    }\n\n    private getHandleMidpointAndOffset(handleElement: HTMLElement, useOppositeDimension = false) {\n        if (handleElement == null) {\n            return { handleMidpoint: 0, handleOffset: 0 };\n        }\n\n        const { vertical } = this.props;\n\n        // N.B. element.clientHeight does not include border size.\n        // Also, element.getBoundingClientRect() is useful to get the top & left position on the page, but\n        // it fails to accurately measure element width & height inside absolutely-positioned and CSS-transformed\n        // containers like Popovers, so we use element.offsetWidth & offsetHeight instead (see https://github.com/palantir/blueprint/issues/4417).\n        const handleRect: DOMRect = handleElement.getBoundingClientRect();\n        handleRect.width = handleElement.offsetWidth;\n        handleRect.height = handleElement.offsetHeight;\n\n        const sizeKey = vertical\n            ? useOppositeDimension\n                ? \"width\"\n                : \"height\"\n            : useOppositeDimension\n              ? \"height\"\n              : \"width\";\n\n        // \"bottom\" value seems to be consistently incorrect, so explicitly\n        // calculate it using the window offset instead.\n        const handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n\n        return { handleMidpoint: handleRect[sizeKey] / 2, handleOffset };\n    }\n\n    private removeDocumentEventListeners() {\n        document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n        document.removeEventListener(\"mouseup\", this.endHandleMovement);\n        document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n        document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n        document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}